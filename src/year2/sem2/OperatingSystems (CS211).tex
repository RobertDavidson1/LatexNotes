\documentclass[a4paper, 10pt]{article}
\input{../../preamble.sty}
\input{../../macros.sty}
\usepackage{listings}
\usepackage[hypcap=false]{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}

\definecolor{commentgreen}{rgb}{0,0.5,0}
\definecolor{keywordsblue}{rgb}{0,0,0.8}
\definecolor{stringspurple}{rgb}{0.58,0,0.82}


\title{
\textbf{CS211: Programing For Operating Systems} \\ 
}

\author{
Robert Davidson
}     
\date{}       

\begin{document}

\maketitle
\pagebreak

\tableofcontents
\pagebreak
\subsection*{Useful headers}
\begin{itemize}
    \item \texttt{stdio.h} : Standard input/output library
    \item \texttt{stdlib.h} : Standard library
    \item  \texttt{string.h} : String manipulation functions (\texttt{strncpy, strcat, strcmp, strstr, strlen})
    \item \texttt{unistd.h} : Standard library for system calls (\texttt{fork, getpid, getppid})
\end{itemize}




\pagebreak
\subsection{Intro to C}

It is a very small language and relies heavily on libraries
The compiler must be told in advance how these functions should be used. So before the compilation process, the \textbf{preprocessor} is run to include the function prototypes The compiler then compiles the code into an object file.

\subsection{Hello World}
\begin{lstlisting}[style=cStyle, caption={Hello World in C}]
    #include <stdio.h>
    int main(){
        printf("Hello World\n");
        return 0;
    }
    \end{lstlisting}
\begin{itemize}
    \item \textbf{Line 1} : \texttt{\#include <stdio.h>} is a preprocessor directive that tells the compiler to include the standard input/output library. This library contains the \texttt{printf} function.
    \item In C almost every line it either preprocessor directive, variable declaration, or a function call.
    \item C uses curly braces to delimit blocks of code and semicolons to terminate statements.
    \item \textbf{Line 4}: In our case, we assume main is called by the Operating System, so return 0 is used to indicate that the program has run successfully.
\end{itemize}

\subsection{Variables}
In C all variables must be declared before they are used. The declaration should have a type; telling the compiler what sort of data the variable will hold. The types of variables are:
\begin{itemize}
    \item \textbf{int} : Integer (1, 2, 3, 4, 5, ...)
    \item \textbf{float} : Floating-point number (7 decimal digits)
    \item \textbf{double} : Double-precision floating-point number (15 decimal digits)
    \item \textbf{char} : Character (a, b, c, ...)
    \item \textbf{void} : No type  (used for functions that do not return a value)
\end{itemize}

We can Also declare arrays as follows:
\begin{lstlisting}[style=cStyle, caption={Declaring Arrays}]
    int arr[5]; // Array of 5 integers
    char name[10]; // Array of 10 characters
\end{lstlisting}
To access the first element of arr we can do \texttt{arr[0]}
\subsection{An Example}
\begin{lstlisting}[style=cStyle, caption={Example of Variables}]
    int d=-101;
    float f=1.23456;
    char c='a';
    printf("Values of d, f, c are: %d, %f, %c\n", d, f ,c );
\end{lstlisting}
\textbf{Explanation:} In this case, \texttt{\%d} is a placeholder for an integer, \texttt{\%f} is a placeholder for a float, and \texttt{\%c} is a placeholder for a character.

\subsection{Operators}

\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description    & Example         \\
        \hline
        +        & Addition       & \texttt{a + b}  \\
        \hline
        -        & Subtraction    & \texttt{a - b}  \\
        \hline
        *        & Multiplication & \texttt{a * b}  \\
        \hline
        /        & Division       & \texttt{a / b}  \\
        \hline
        \%       & Modulus        & \texttt{a \% b} \\
        \hline
    \end{tabular}
    \captionof{table}{Arithmetic Operators}
\end{minipage}
\hfill
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description         & Example          \\
        \hline
        =        & Assignment          & \texttt{a = b}   \\
        \hline
        +=       & Add and assign      & \texttt{a += b}  \\
        \hline
        -=       & Subtract and assign & \texttt{a -= b}  \\
        \hline
        *=       & Multiply and assign & \texttt{a *= b}  \\
        \hline
        /=       & Divide and assign   & \texttt{a /= b}  \\
        \hline
        \%=      & Modulus and assign  & \texttt{a \%= b} \\
        \hline
        ++       & Increment           & \texttt{a++}     \\
        \hline
        --       & Decrement           & \texttt{a--}     \\
        \hline
    \end{tabular}
    \captionof{table}{Assignment and Arithmetic Assignment Operators}
\end{minipage}

\vspace{1em}
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description      & Example         \\
        \hline
        ==       & Equal            & \texttt{a == b} \\
        \hline
        !=       & Not Equal        & \texttt{a != b} \\
        \hline
        >        & Greater          & \texttt{a > b}  \\
        \hline
        <        & Less             & \texttt{a < b}  \\
        \hline
        >=       & Greater or Equal & \texttt{a >= b} \\
        \hline
        <=       & Less or Equal    & \texttt{a <= b} \\
        \hline
    \end{tabular}
    \captionof{table}{Relational Operators}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description & Example           \\
        \hline
        \&\&     & Logical AND & \texttt{a \&\& b} \\
        \hline
        ||       & Logical OR  & \texttt{a || b}   \\
        \hline
        !        & Logical NOT & \texttt{!a}       \\
        \hline
    \end{tabular}
    \captionof{table}{Logical Operators}
\end{minipage}





\subsection{Control Structure}
\begin{lstlisting}[style=cStyle, caption={If-Else}]
    int a = 10;
    if(a > 10){
            printf("a is greater than 10\n");
        }else if(a == 10){
            printf("a is equal to 10\n");
        }else{
    printf("a is less than 10\n");
    }
    \end{lstlisting}
Logical opeators, \texttt{\&\&} and \texttt{||} can be used to make more complex conditions.
\begin{lstlisting}[style=cStyle, caption={Complex If-Else}]
    if(a > 10 && a < 20){
        printf("a is between 10 and 20\n");
    }
    \end{lstlisting}
\subsubsection{For loop}
\texttt{for(initial val; continuation condition; increment/decrement)\{...\}}

\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
for(int i = 0; i < 10; i++){
    printf("i is %d\n", i);
}
\end{lstlisting}
\pagebreak
\subsubsection{While loop}
\texttt{while(expression)\{...\}}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
while(i < 10){
    printf("i is %d\n", i);
    i++;
}
\end{lstlisting}
\subsubsection{Do While loop}
\texttt{do\{...\}while(expression);}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
do{
    printf("i is %d\n", i);
    i++;
}while(i < 10);
\end{lstlisting}

\subsection{Output}
\texttt{printf()} is used to print formatted output to the screen. It is a variadic function, meaning it can take any number of arguments. The first argument is a format string, followed by the values to be printed.\\[2ex]
The format string may contain a number of escape characters, represented by a backslash. Some of the most common escape characters are:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Sequence                               & Description                                  \\
        \hline
        \texttt{\textbackslash a}              & Produces a beep or flash                     \\
        \hline
        \texttt{\textbackslash b}              & Moves cursor to last column of previous line \\
        \hline
        \texttt{\textbackslash f}              & Moves cursor to start of next page           \\
        \hline
        \texttt{\textbackslash n}              & New line                                     \\
        \hline
        \texttt{\textbackslash r}              & Carriage return                              \\
        \hline
        \texttt{\textbackslash t}              & Tab                                          \\
        \hline
        \texttt{\textbackslash v}              & Vertical tab                                 \\
        \hline
        \texttt{\textbackslash \textbackslash} & Prints a backslash                           \\
        \hline
        \texttt{\textbackslash '}              & Prints a single quote                        \\
        \hline
    \end{tabular}
\end{center}
A conversion character is a letter that follows a \texttt{\%} and tells \texttt{printf()} to display the value stored in the corresponding variable. Some of the most common conversion characters are:
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Specifier                    & Description                                  \\
        \hline
        \texttt{\%c}                 & Single character (char)                      \\
        \hline
        \texttt{\%d} or \texttt{\%i} & Decimal integer (int)                        \\
        \hline
        \texttt{\%e} or \texttt{\%E} & Floating-point (scientific notation)         \\
        \hline
        \texttt{\%f}                 & Floating-point value (float)                 \\
        \hline
        \texttt{\%g} or \texttt{\%G} & Same as \%e/\%E or \%f, whichever is shorter \\
        \hline
        \texttt{\%s}                 & String (char array)                          \\
        \hline
        \texttt{\%u}                 & Unsigned int                                 \\
        \hline
        \texttt{\%x}                 & Hexadecimal integer                          \\
        \hline
        \texttt{\%p}                 & Pointer (memory address)                     \\
        \hline
        \texttt{\%\%}                & Prints the \% character                      \\
        \hline
    \end{tabular}
\end{center}
\pagebreak
\subsection{Input}
\texttt{scanf()} reads input from standat input, format it, as directed by a conversion character and store the address of a specified variable.
\begin{lstlisting}[style=cStyle, caption={Reading an integer}]
    int number; 
    char letter; 
    printf("Enter a number and a char: ");
    scanf("%d %c", &number, &letter);

    printf("You entered: %d and %c\n", number, letter);
\end{lstlisting}
\begin{itemize}
    \item The scan \texttt{scanf()} returns an integer equal to the number of successfull conversions made.
    \item There is related function \texttt{fscanf()} that reads from a file. \texttt{scanf()} is really just a wrapper for \texttt{fscanf()} that treats the keyboard as a file.
    \item There are other useful functions for readint the standard input stream: \texttt{getchar()} and \texttt{gets()}.
\end{itemize}
\begin{lstlisting}[style=cStyle, caption={Check for no input}]
    int number;
    printf("Enter a number between 1 and 30: ");
    scanf("%d", &number);

    while ((number<1) || (number>30))
    {
        printf("Invalid number. Please enter a number between 1 and 30: ");
        scanf("%d", &number);
    }
\end{lstlisting}

\subsection{Functions}
\begin{definitionbox}{Protype and Definition}{}
    A \textbf{Protype :} A function prototype is a declaration of a function that tells the compiler what the function looks like. It includes the function name, return type, and parameter types. The prototype must be declared before the function is called. \\
    \textbf{Definition :} A function definition is the actual implementation of the function. It includes the function name, return type, parameter types, and the body of the function. The definition must be declared after the function is called.
\end{definitionbox}

\subsection{Call-by-Value and Pointers}
In C is it important to distuinguish between a variable and the value stored in it. A variable has a location in memory. The value of the variable is stored in that location. For example:
\begin{lstlisting}[style=cStyle]
int i = 10;
\end{lstlisting}
tells the system to allocate a location in memory to store the value 10. The variable \texttt{i} is a pointer to that location in memory. One of the distuinguihing features of C is it we can manipulate the memory address of the variable almost as easily as we can manipulate the value stored in it.
\begin{conceptbox}{Pointers}{}
    \begin{itemize}
        \item if \texttt{i} is a variable, then \texttt{\&i} is a pointer to the location in memory where the value of \texttt{i} is stored.
              If a memory address is stored in the variable \texttt{p}, then \texttt{*p} is the value stored at that address.
        \item If a memory address is stored in the variable \texttt{p}, then \texttt{*p} is the value stored at that address.
    \end{itemize}
\end{conceptbox}
\pagebreak
\subsection{Characters}
\begin{conceptbox}{Character representation}{}
    In C, a character is just an unsigned integer. Each character is represented by an integer between 0 and 127.
\end{conceptbox}

\begin{minipage}{0.45\textwidth}
    \textbf{Printing characters:}

    \begin{itemize}
        \item \texttt{printf("\&c", c)}
        \item \texttt{putchar(c)}
    \end{itemize}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \textbf{Reading characters:}
    \begin{itemize}
        \item \texttt{scanf("\&c", c)}
        \item \texttt{c = getchar()}
    \end{itemize}
\end{minipage}
\subsection{Strings}
\begin{conceptbox}{String representation}{}
    C does not have a string data type. Instead it uses arrays of type char to represent strings. For example if we make a declaration:
    $$\texttt{char greeting[20]="Hello. How are you?";}$$
    the system stores each character as an element of the array greeting.
\end{conceptbox}
\subsubsection{String Functions}
Useful functions defined in \texttt{string.h}: \\[2ex]
$$\texttt{char *strncp(char *dest, char *src, int n)} $$
Copies at most \texttt{n} characters from \texttt{src} to \texttt{dest}. The advantage of this is that we don't copy more chatavyers to \texttt{dest} than it can hold (prevents buffer overflow). \texttt{strncpy()} does not append a null character to the end of the string, so we need to do that manually. \\[2ex]
$$\texttt{char *strcat(char *dest, char *src)}$$
Concatenates the string \texttt{src} to the end of the string \texttt{dest}. The destination string must be large enough to hold the concatenated result. \texttt{strcat()} appends a null character to the end of the string. \\[2ex]
$$\texttt{int strcmp(char *str1, char *str2)}$$
Compares two strings annd returns an intger:
\begin{itemize}
    \item 0 if the strings are equal
    \item A negative integer if \texttt{str1} comes first alphabetically
    \item A negative integer if \texttt{str2} comes first alphabetically
\end{itemize}
$$\texttt{char *strstr(char *haystack, char *needle)} $$
Searches for the first occurrence of the string \texttt{needle} in the string \texttt{haystack}. If found, it returns a pointer to the first occurrence of \texttt{needle} in \texttt{haystack}. If not found, it returns NULL. \\[2ex]
$$\texttt{int strlen(char *str)}$$
Returns the length of the string \texttt{str} (not including the null character).

\pagebreak
\subsection*{1.11 Strings (Continued)}
\subsubsection{String Output}
We know how to use \texttt{printf()} to print strings:
\begin{itemize}
    \item \texttt{printf("\%s\%s$\backslash$n, "Good Morning ", name);}
    \item \texttt{printf("\%s\%8s$\backslash$n", "Good Morning ", name);}
\end{itemize}
The second example, the field width specifier is given. This causes the string to be padded so it takes up a total of 8 spaces. If the string is shorter than 8 characters, it is padded with spaces on the left. If the string is longer than 8 characters, it is printed as is.

\subsubsection{String Input}
\begin{itemize}
    \item \texttt{scanf("\%s", name);} reads the next "word" from th input stream and stores it in the array \texttt{name}. A "word" is defined as a sequence of characters separated without a space, tab, or newline. The string is terminated with a null character.
    \item \texttt{getchar(name);} to get more control of the input in a loop
    \item \texttt{gets(string);} reads a line input and stores it all except the newline character. The string is terminated with a null character. \texttt{gets()} is not safe to use because it does not check the length of the input string. If the input string is longer than the array, it will cause a buffer overflow and overwrite other data in memory.
    \item \texttt{fgets(string, n, stdin);} reads in a line of text from the keyboard (standard input stream) and stores at most \texttt{n} characters in the array \texttt{string}. The string is terminated with a null character. If the input string is longer than \texttt{n}, it will be truncated and the rest will be discarded. \texttt{fgets()} is safer to use than \texttt{gets()} because it checks the length of the input string.
\end{itemize}
\subsection{Arrays}
\subsection{Arrays}
To declare a $3 \times 4$ matrix of floats, we write \texttt{float a[3][4];}. So:
$$\begin{bmatrix}
        a[0][0] & a[0][1] & a[0][2] & a[0][3] \\
        a[1][0] & a[1][1] & a[1][2] & a[1][3] \\
        a[2][0] & a[2][1] & a[2][2] & a[2][3]
    \end{bmatrix}
$$
In general, an $n \times m$ array is declared as \texttt{float a[n][m];}. The first index is the row number and the second index is the column number. The first element of the array is \texttt{a[0][0]} and the last element is \texttt{a[n-1][m-1]}. \\[2ex]
If a has the line \texttt{int [a][4];} then the system creats three arrays, each of length four. More precisely, it:
\begin{itemize}
    \item declares 3 pointers to type \texttt{int}: \texttt{a[0]}, \texttt{a[1]}, and \texttt{a[2]}
    \item space for storing an integer is allocated to each of addresses \texttt{a[0], a[0]+1, a[0]+2, a[0]+3, a[1], a[1]+1}, $\dots$, \texttt{a[2]+3}
\end{itemize}
This mean is if \texttt{a[][]} is declared as a two-dimensional $3 \times 4$ array, then the following are equivalent:
\begin{itemize}
    \item \texttt{a[1][2]}
    \item \texttt{*(a[1]+2)}
    \item \texttt{*(*(a+1)+2)}
    \item \texttt{*(\&a[0][0]+4+2)}
\end{itemize}
\pagebreak
\subsection{Explanation of Array Element Access in C}

\subsubsection*{\texttt{a[1][2]}}
This is the standard way to access a two-dimensional array element. It directly fetches the element in the second row (index 1) and the third column (index 2).

\subsubsection*{\texttt{*(a[1]+2)}}
\begin{itemize}
    \item \texttt{a[1]} yields the second row, which decays to a pointer to its first element (i.e., equivalent to \texttt{\&a[1][0]}).
    \item Adding \texttt{2} moves the pointer two elements forward in that row.
    \item The dereference operator \texttt{*} then accesses the element at that position, which is \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(*(a+1)+2)}}
\begin{itemize}
    \item \texttt{a+1} moves the pointer from the first row to the second row.
    \item \texttt{*(a+1)} dereferences that pointer to yield the address of the first element of the second row (again, equivalent to \texttt{a[1]}).
    \item Adding \texttt{2} moves to the third element in that row, and the outer \texttt{*} fetches its value \rule{\textwidth}{0.5pt}again, \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(\&a[0][0]+4+2)}}
\begin{itemize}
    \item \texttt{\&a[0][0]} gets the address of the very first element of the array.
    \item Since the array is stored in contiguous memory, pointer arithmetic treats it as a flat sequence. Adding \texttt{4+2} (i.e., 6) moves the pointer to the 7th element in that sequence.
    \item If the layout of the array is such that the element \texttt{a[1][2]} is the 7th element (this is true, for example, if the row length is at least 3), then dereferencing this pointer retrieves \texttt{a[1][2]}.
\end{itemize}

\subsection{Files}
Taking an input from a file is not much different than taking input from a keyboard. All we do is:
\begin{itemize}
    \item Declare an identifier of type \texttt{FILE} to hold the file pointer.
    \item Open the file (\texttt{fopen()})
    \item Read the file
    \item Close the file (\texttt{fclose()})
\end{itemize}
\subsection{Declaring a file indentifier:}
$$\texttt{FILE *datafile;}$$
The datafile is now a pointer we can associate with a file. The \texttt{FILE} type is defined in the \texttt{stdio.h} library.
\subsection{Opening a file:}
$$\texttt{fileptr = fopen(char *filename, char *mode);}$$
The \texttt{fopen()} is a function that is use for file opening. It takes two arguments: the name of a file and the mode it will operrate in. A file pointer is returned. The mode can be:
\begin{itemize}
    \item \texttt{r} : read (open an existing file for reading)
    \item \texttt{w} : write (overrwite the file or create a new one)
    \item \texttt{a} : append (add to the end of the file)
\end{itemize}
\subsection{Closing a File}
$$\texttt{fclose(fileptr);}$$
Once a file is “closed” we can no longer read from it or write to it, unless
we open it again. If we don’t do this, the file will still be closed when the
program terminates. But until then, no other program on the same node
(computer) can work with the file, and it might but be fully written to
storage
\subsection{Reading from a file}
$$\texttt{fgets(char *str, int n, FILE *fileptr);}$$
reads in a line of text from the fileptr stream and stores at most n
characters in array sting. The mew line character is stored.
If the string can’t be read, because we have reached the end of the file,
then NULL is returned.
$$\texttt{fgetc(FILE *fileptr);}$$
reads the next character in the file and stores it in the char variable c. If
the end of the file has been reached, EOF is returned.
$$\texttt{fscanf(FILE *fileptr, char *format, ...);}$$
reads formatted input from the file. The format string is similar to the
one used in \texttt{printf()}
\subsection{Navigating a file}
Each time a character is reader from the input stream, a counter associated with the stream is incremented.
$$\texttt{rewind(FILE *fileptr);}$$
sets the indicator to the start of the file
$$\texttt{ftell(FILE *fileptr);}$$
is used to check the current value of the file position indivator in the form of a long int.
$$\texttt{fseek(FILE *fileptr, long offset, int place);}$$
the value of offset is the amount the indicator will be changed by, while placce is one of:
\begin{itemize}
    \item \texttt{SEEK\_SET(0)} : the start of the file
    \item \texttt{SEEK\_CUR(1)} : the current position in the file
    \item \texttt{SEEK\_END(2)} : the end of the file
\end{itemize}
\subsection{Writing to a file}
To write to a file, we declare a file pointer:
$$\texttt{FILE *outfile;}$$
and open a new file in write mode:
$$\texttt{outfile = fopen("myList.txt", "w");}$$
to write to the file, we use one of:
\begin{itemize}
    \item \texttt{fprintf(outfile, char *format, ...);} : works like \texttt{printf()} except its first argument is a file pointer
    \item \texttt{fputs(char *str, FILE *fileptr);} : writes the string str to the file pointed to by fileptr, without its trailing '\texttt{\textbackslash 0}' character. The string is not formatted.
    \item \texttt{fputc(int c, FILE *fileptr);} : writes the character c to the file pointed to by fileptr. The character is not formatted.
\end{itemize}
\pagebreak
\subsection{Issues concerining the use of files in C, we should be aware of:}
\begin{itemize}
    \item There are 6 modes a file can have: \texttt{r, w, a, r+, w+, a+}
    \item To open a binary file, also add a \texttt{b} to the mode. For example, \texttt{rb} opens a file for reading in binary mode.
    \item \texttt{freopen()} attaches a new file to an existing file pointer. It is used to redirect the standard input or output to a file. For example, \texttt{freopen("myList.txt", "w", stdout);} redirects the standard output to the file \texttt{myList.txt}. This means that any output that would normally go to the screen will now go to the file.
    \item \texttt{tmpfile()} open a tempory file in binary read/write and is automatically deleted when closed or when the program terminates
    \item \texttt{fflush(fileptr);} flushes the output buffer of the file pointer. This means that any data that has been buffered but not yet written to the file will be written to the file.
    \item \texttt{remove("myList.txt");} deletes the file \texttt{myList.txt} from the disk.
    \item \texttt{rename("myList.txt", "myList2.txt");} renames the file \texttt{myList.txt} to \texttt{myList2.txt}. If the new name already exists, it will be overwritten.
    \item \texttt{int feof(FILE *fileptr);} returns a non-zero value if the end of the file has been reached. It is used to check if we have reached the end of the file while reading it.
\end{itemize}

\subsection{The Process}
$$\textbf{"A process is a running program."}$$
The operating system gives the impression many programs are running at the same time, but in reality, only one program is running at a time. This is made possible by abstracting the the concept of a running program as a process.
\begin{conceptbox}{Every process has}{}
    \begin{itemize}
        \item \textbf{The process text:} the program code
        \item \textbf{The program counter:} the address of the next instruction to be executed
        \item \textbf{The process stack:}  temporary data, local variables, function parameters, return addresses
        \item \textbf{The data section:}  global variables
    \end{itemize}
\end{conceptbox}
A process is not just a program - if two users run the same program at the same time, they create different processes. Each process has its own memory space, so they do not interfere with each other. A program is a passive entity, while a process is an active / dynamic entity.
\begin{conceptbox}{Operations OS must perform on a process}{}
    \begin{itemize}
        \item \textbf{Create} a new process (open a new program)
        \item \textbf{Terminate / Destory} a process (close a program)
        \item \textbf{Wait} or pause a process until some event occurs (e.g. waiting for user input)
        \item \textbf{Supsend and Resume} similar to wait but more explicit
        \item \textbf{Status}  report info about a process (e.g. how much memory it is using, how long it has been running, etc.)
    \end{itemize}
\end{conceptbox}
\begin{conceptbox}{States of a process}{}
    \begin{itemize}
        \item \textbf{New} : the process is being created
        \item \textbf{Running} : instructions being executed
        \item \textbf{Block / Waiting} : waiting for some event to occur (e.g. I/O operation)
        \item \textbf{Ready} : waiting to be assigned to a processor
        \item \textbf{Terminated} : the process has finished executing
    \end{itemize}
\end{conceptbox}

\pagebreak
\subsection{Process Creation}
A parent creates a child process. The child process can create its own child, forming a tree of processes. After a parent creates a child process it may:
\begin{itemize}
    \item \textbf{Execute} concurrently with the child process
    \item \textbf{Wait} until the child process terminates to continue
\end{itemize}
The parent may share all, none or some of its resources with the child process (memory space, open files, etc.)
\subsection{Process Identifcation Number}
ll processes have a unique identifier called a \textbf{PID}. If we create a child process in C, using a \texttt{fork()} a new process is created:
\begin{itemize}
    \item The new process runs \textbf{concurrently} with the parent, unless we instruct it to \texttt{wait()}.
    \item The subproc (child) is given a \textbf{copy of the parents memory space}
    \item At the time of creation, the two processes are identical, except the \texttt{fork()} returns te child process' PID to the parent and 0 to the child.
\end{itemize}
In order to use \texttt{fork()} , we must include the \texttt{unistd.h} library, which includes:
\begin{itemize}
    \item \texttt{fork()} - creates a new process
    \item \texttt{getpid()} - returns the PID of the calling process
    \item \texttt{getppid()} - returns the PID of the parent process
\end{itemize}
\subsubsection{\texttt{unistd.h} functions}
$$\boxed{\texttt{pid\_t fork(void);}}$$
\begin{itemize}
    \item It takes no arguments
    \item It really returns an \texttt{int}
    \item It returns -1 if the fork failed
    \item Otherwise, it returns the PID of the newly created child process to the parent process
    \item It returns 0 to the child process
    \item The child process is distinct from the parent (it gets its own copy of the parent's memory space)
    \item Both parent and child process run concurrently
    \item Starting from the \texttt{fork()} call, the parent and child process execute the same instruction set.
\end{itemize}
$$\boxed{\texttt{pid\_t getpid(void);}}$$
Returns the value of the processes own PID
$$\boxed{\texttt{pid\_t getppid(void);}}$$
Returns the value of the parent process' PID
Since the parent and subproc (child) have copies of the same memory space and instruction set, \texttt{getpid()}  and \texttt{getppid()} are useful for working out which is which.
\pagebreak
\subsection{Process Programming}
Often we don't want the parent to continue running while the child is running, the results may be non-deterministic. Recall a sub-proc will share the parents memory only in a sense that it recieves a copy. The  child process can mimic the parents execution  or its memory space may be overlaid with a new program/set of instructions. \\[2ex]

Often when a child process is created it is overlaid with another program. In C, this can be done with the {exelclp()} function. In the following example, the sub-procs memory space is overlaid the program text of the ls command.  Again we will use the \texttt{wait()} function.\\[2ex]
The OS is responsible for \textbf{de-allocating the resources} of a process that has finished. It may also be responsible for terminating a process that is not responding.
\begin{conceptbox}{Processes are terminated when}{}
    \begin{itemize}
        \item The proc executes its last instruction and asks the operating system to delete it (\texttt{exit()}). At that time it will usualy:
              \begin{itemize}
                  \item Output data from subproc to parent (via \texttt{wait()})
                  \item Have its resources de-allocated by the OS
              \end{itemize}
        \item Parent terminates a child process because:
              \begin{itemize}
                  \item Sub-proc has exceeded allocated resources
                  \item The task assigned to the sub-proc is no longer needed
              \end{itemize}
        \item The parent is exiting and the OS does not allow subproc to continue if the parent is terminated
    \end{itemize}
\end{conceptbox}
\subsection{Signals}
The \texttt{kill()} system call is an example of a signal - a form of communication from one process to another. These provide a facility for asynchronus event handling. Note - when the subproc sends the kill() signal to the parent, the subproc also terminates. \\[2ex]
The \texttt{kill()} function can send other signals, but most (such as SIGABRT, SIGILL, SIGQUIT, SIGTERM) are just variants of SIGKILL. However there are signals that preform other taks.
\begin{conceptbox}{Types of Signals}{}
    \begin{itemize}
        \item \textbf{SIGSTOP:} stops a process
        \item \textbf{SIGCONT:} continues a stopped process
        \item \textbf{SIGUSR1:} user defined signal 1
        \item \textbf{SIGUSR2:}  user defined signal 2
    \end{itemize}
\end{conceptbox}
The kill function can take two arguments:
$$\texttt{kill(pid\_t pid, int sig);}$$
the PID of the process to send the signal to and the signal to send. The function returns 0 on success and -1 on failure. The \texttt{kill()} function can be used to send any signal to any process, including itself. \\
With the \texttt{signal()} function, we can send a signal that tells the process to preform a specific asction, when it recieves a \texttt{SIGUSR1} or \texttt{SIGUSR2} signal.

\pagebreak

\subsection{Inter Process Communication}
Inter process communication (IPC) is a mechanism that allows processes to communicate with each other. This is important because processes may need to share data or synchronize their actions

\begin{conceptbox}{Types of Process Communication}{}
    \begin{itemize}
        \item \textbf{Independent} : Cannot affect or be affected by each other
        \item \textbf{Co-operating} : Can be affected by the execution of eachother
    \end{itemize}
\end{conceptbox}
\begin{conceptbox}{Why we allow IPC}{}
    \begin{itemize}
        \item \textbf{Information sharing} - two procs might require acess to the same file
        \item \textbf{Modularity} - Different procs might be dedicated to different system functions
        \item \textbf{Convenience} - a user might be running an editor, spell checker and printer all for the same file
        \item \textbf{Computational Speed} - on a multiprocessing system tasks are sub-divided and executred conrurrently on different processors.
    \end{itemize}
\end{conceptbox}

\begin{definitionbox}{Producer Consumer Model}{}
    One process (editor) has information it wants to produce for consumption by another (printer). This may be done by a \textbf{mutual/shared buffer}. Producer write to the buffer and consumer reads from it.
\end{definitionbox}
\begin{conceptbox}{Shared Buffer Types}{}
    \begin{itemize}
        \item \textbf{Un-bounded} : no size limit placed on the buffer. The producer may continue to produce and write to the buffer as long as it wants to.
        \item \textbf{Bounded} : strict size limit on the buffer. If full, producer must wait until consumer removes some data.
    \end{itemize}
\end{conceptbox}
\begin{conceptbox}{How we implement shared buffers}{}
    \begin{itemize}
        \item \textbf{Physically} by a set of shared variables (shared memory addresses), the implementation of this is the responsibility of the programmer.
        \item \textbf{Logically} by message passing using an Inter Process Communication. Such system is inplemented by the OS.. The IPC prodives a logical communcation link via a message passing facilitiy with two funadmental operations : \textbf{send message} and \textbf{recieve message}.
    \end{itemize}
\end{conceptbox}

\pagebreak
\subsubsection{Direct Communication}
Each process must nomiate the process they want to communicate it. Pairs of cumminicting processes must know each others ID's in order to etablish a link. With this system a link is established by the two processes automatically, there are exactly two processes in the link and there can be at most one link between two procss\\[2ex]
This is an example of \textbf{Symmetric addressing}. In the \textbf{Asymmetric addressing} model, the recipient listens out for any messages addressed to it (like making a phone call).\\[2ex]
\textbf{Disadvantages}
\begin{itemize}
    \item Processes must have details of eachother befoe they can communicate
    \item One link between processes only
    \item Only two processes can communicate at a time
\end{itemize}
\subsubsection{Indirect Communication}
The alternative is to have a number of ports (mailboxes) in the sytem. Each with a unique ID. \\[2ex]
For procs to communicae they must know the name of the mailbox. More than two procs can share a mailbox . Two procs may share more than one mailbox \\[2ex]
\textbf{Disadvantages}
\begin{itemize}
    \item Mailbox is owned by only one proc. Several procs can write to it, but only one can read from it.
    \item Procs are owned only by the OS. Permissions are then granted to processes to create and delete mailbox and to send and receive messages.
\end{itemize}
\subsection{\texttt{pipe()}}
A means of communication, based around the \texttt{pipe(), write(), read()} functions that allows one process to send data to another. The data can be anything, but we will use examples of sending integers. This is an example of \textbf{Symmetric direct communication}.

\subsection{Theads}
So far, we've assumed that every process has its own program counter (PC), which tells the OS where it is in its instruction set (think line of program currently executing). So even when we duplicate using \texttt{fork()} the new subproc has its own PC, even though they have the same value as the parents PC. \\[2ex]
However, modern OS's allow for threads: single process that can have mulitple PC's.

\begin{conceptbox}{Why threads are useful}{}
    \begin{itemize}
        \item The process may need to preform lots of operations at the same time (on different cores) on the same data - i.e. adding vectors
        \item Processes have to preform different operation that run at different speeds, such as adding vectors (fast) and waiting for user input (slow)
    \end{itemize}
\end{conceptbox}
But, with subprocs made with \texttt{fork()} memory is not really shared, so the advantage of being able to do things at once is lost by the need to communicate.
\pagebreak
\subsection{Single Point of Exuction vs Multiple Points of Execution}
Instead of our classic view of a single point of execution withing a program, a multi-threaded program has more than one point of execution. Each thread is very much like a seperate process, except for \textbf{one difference:} they share the same address and space and thus can acess the same data.
\begin{definitionbox}{Thread}{}
    A thread (or lightweight process) is a basic unit of CPU utilization. Rather than a process being dedicated to one sequential list of tasks it may be broken into threads. These consists a set of distinct:
    \begin{itemize}
        \item \textbf{Program Counter} - the next instruction to be executed
        \item \textbf{Register set} - operands for CPU instructions
        \item \textbf{Stack} - temporary variables, etc.
    \end{itemize}
\end{definitionbox}
\begin{definitionbox}{Task}{}
    A task is a collection of threads that belong to the same process and share code section, data section, and operating-system resources.
\end{definitionbox}
\begin{conceptbox}{Why use threads over processes}{}
    \begin{itemize}
        \item \textbf{Parallization} - Each thread can execute on a different processor core.
        \item \textbf{Responsiveness} - A part of a process may continue working, even if another part is blocked, i.e. waiting for an I/O operation
        \item \textbf{Resource Sharing} - For exampl we can have several hundred threads running at the same time. If they were all processes, we would have to allocate memory for each one. This is not the case with threads, as they share the same address space.
        \item \textbf{Economy} - Thread creation is faster than process creation and context switching is faster
        \item \textbf{Efficiency} - Threads belong to the same proc share common memory space and do not need support from the OS to communicate.
    \end{itemize}
\end{conceptbox}
\subsection{Two types of threads - User and Kernel}

On Linux, Mac and related systems, in C we can create threads called \texttt{pthreads} (POSIX threads) which are defined in the \texttt{pthread.h} header. We will use two functions:
\begin{itemize}
    \item \texttt{pthread\_create()} - used for creating thread and takes four arguments.
          \begin{itemize}
              \item ID of thread process
              \item Thread attributes (we'll ignore and use NULL)
              \item A function called by thread when created
              \item Argument to pass to the function.
          \end{itemize}
    \item \texttt{pthread\_join()} - tells parent to wait for a thread to finish
\end{itemize}

\begin{table}[h!]
    \centering
    \begin{tabularx}{\textwidth}{@{} l X X @{}}
        \toprule
        Thread Type    & User Threads                                                                                                  & Kernel Threads                                                                                                               \\
        \midrule
        Implementation & Implemented by a thread library at compiler/library level above the OS kernel                                 & Created, managed and scheduled by the operating system kernel                                                                \\
        Advantages     & Quick to create and destroy since system calls are not required                                               & Do not suffer from blocking problems; if one thread blocks, the kernel can schedule another thread from the same application \\
        Disadvantages  & If the kernel is not threaded and one thread makes a blocking system call, the entire process will be blocked & Slower to manipulate compared to user threads due to system call overhead                                                    \\
        \addlinespace[2ex]
        \bottomrule
    \end{tabularx}
\end{table}

\subsection{Sheduling Algorithms}
$$\textbf{"Several process/jobs are available to be run. In what order should they be executed?}$$
\subsection{Metrics to Compare Algoritms}
\begin{conceptbox}{Metrics to Compare Algorithms}{}
    \begin{itemize}
        \item \textbf{Turnaround time} - the total time taken to execute a process. It is the sum of the waiting time and the burst time.
        \item \textbf{Waiting time} - the total time a process has been waiting in the ready queue.
        \item \textbf{Response time} - the time taken from when a request was submitted until the first response is produced.
    \end{itemize}
\end{conceptbox}
\begin{table}[h!]
    \centering
    \begin{tabularx}{\textwidth}{@{} X X X @{}}
        \toprule
        Algorithm                & Advantages                                                                                                                    & Disadvantages \\
        \midrule
        FIFO (First In First Out)
                                 & Simple to implement, only need a FIFO queue. It is non-preemptive
                                 & Has a long average weight time, and suffers from the \textbf{convoy effect} (short jobs wait for long jobs)
        \\
        \addlinespace[2ex]
        SJF (Shortest Job First) & Optimal - minimum average waiting time for a given set of processes.
        Is non pre-eemptive.
                                 & Cannot be emplyed in a realisting setting because we would be required to know the length of next CPU Burst before it happens
        \\
        \addlinespace[2ex]
        STCF (Shortest Time to Completion First)
                                 & "More optimal” than SJF when processes arrive at
        different times
                                 & Needs preempting
        \\
        \addlinespace[2ex]
        RR (Round Robin)         & Fair, each process gets a fair share of the CPU. It is preemptive and simple to implement
                                 & Average waiting time is high, and it is not optimal for short jobs
    \end{tabularx}
\end{table}
\subsection{RR - Round Robin}
\begin{definitionbox}{Round Robin}{}
    A preemptive version of FIFO. Each process is assigned a time slice (quantum) and is executed for that time. If it does not finish, it is put back in the queue and the next process is executed.
\end{definitionbox}
\begin{examplebox}{}{}
    \scriptsize
    \begin{tabularx}{\textwidth}{@{} l X X @{}}
        \toprule
        Proc  & Arrival Time & Burst Time \\
        \midrule
        $P_1$ & 0            & 20         \\
        $P_2$ & 0            & 15         \\
        $P_3$ & 4            & 10         \\
        $P_4$ & 6            & 5          \\
    \end{tabularx}\\[2ex]
    \rule{\textwidth}{0.5pt}
    \textbf{1. First-Come, First-Served (FCFS)}

    \begin{minipage}[t]{0.48\textwidth}
        Order: $P_1 \rightarrow P_2 \rightarrow P_3 \rightarrow P_4$

        \begin{itemize}
            \item $P_1$: starts at 0, ends at 20
            \item $P_2$: starts at 20, ends at 35
            \item $P_3$: starts at 35, ends at 45
            \item $P_4$: starts at 45, ends at 50
        \end{itemize}

        \begin{align*}
            \text{TAT} & = \text{Completion Time} - \text{Arrival Time} \\
            \text{WT}  & = \text{TAT} - \text{Burst Time}               \\
            \text{RT}  & = \text{Start Time} - \text{Arrival Time}
        \end{align*}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{center}
            \begin{tabular}{@{} l c c c c @{}}
                \toprule
                Process & CT & TAT & WT & RT \\
                \midrule
                $P_1$   & 20 & 20  & 0  & 0  \\
                $P_2$   & 35 & 35  & 20 & 20 \\
                $P_3$   & 45 & 41  & 31 & 31 \\
                $P_4$   & 50 & 44  & 39 & 39 \\
                \bottomrule
            \end{tabular}
        \end{center}

        \begin{align*}
            \text{Average TAT} & = \frac{20 + 35 + 41 + 44}{4} = 35  \\
            \text{Average WT}  & = \frac{0 + 20 + 31 + 39}{4} = 22.5 \\
            \text{Average RT}  & = \frac{0 + 20 + 31 + 39}{4} = 22.5
        \end{align*}
    \end{minipage}

    \rule{\textwidth}{0.5pt}

    \textbf{2. Shortest Job First (SJF, Non-preemptive)}

    \begin{minipage}[t]{0.48\textwidth}
        \begin{itemize}
            \item At time 0: $P_1$, $P_2$ ready → pick $P_2$
            \item At time 15: $P_1$, $P_3$ ready → pick $P_3$
            \item At time 25: $P_1$, $P_4$ ready → pick $P_4$
            \item At time 30: $P_1$ runs
        \end{itemize}

        \begin{itemize}
            \item $P_2$: start 0, end 15
            \item $P_3$: start 15, end 25
            \item $P_4$: start 25, end 30
            \item $P_1$: start 30, end 50
        \end{itemize}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{center}
            \begin{tabular}{@{} l c c c c @{}}
                \toprule
                Process & CT & TAT & WT & RT \\
                \midrule
                $P_2$   & 15 & 15  & 0  & 0  \\
                $P_3$   & 25 & 21  & 11 & 11 \\
                $P_4$   & 30 & 24  & 19 & 19 \\
                $P_1$   & 50 & 50  & 30 & 30 \\
                \bottomrule
            \end{tabular}
        \end{center}

        \begin{align*}
            \text{Average TAT} & = \frac{15 + 21 + 24 + 50}{4} = 27.5 \\
            \text{Average WT}  & = \frac{0 + 11 + 19 + 30}{4} = 15    \\
            \text{Average RT}  & = \frac{0 + 11 + 19 + 30}{4} = 15
        \end{align*}
    \end{minipage}

    \rule{\textwidth}{0.5pt}

    \textbf{3. Round Robin (RR), Time Quantum = 10}

    \begin{minipage}[t]{0.48\textwidth}
        Execution sequence:
        \begin{itemize}
            \item 0-10: $P_1$ (rem 10)
            \item 10-20: $P_2$ (rem 5)
            \item 20-30: $P_3$ (done)
            \item 30-35: $P_4$ (done)
            \item 35-45: $P_1$ (done)
            \item 45-50: $P_2$ (done)
        \end{itemize}

        Response times:
        \begin{itemize}
            \item $P_1$: 0
            \item $P_2$: 10
            \item $P_3$: 20
            \item $P_4$: 30
        \end{itemize}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{center}
            \begin{tabular}{@{} l c c c c @{}}
                \toprule
                Process & CT & TAT & WT & RT \\
                \midrule
                $P_1$   & 45 & 45  & 25 & 0  \\
                $P_2$   & 50 & 50  & 35 & 10 \\
                $P_3$   & 30 & 26  & 16 & 20 \\
                $P_4$   & 35 & 29  & 24 & 30 \\
                \bottomrule
            \end{tabular}
        \end{center}

        \begin{align*}
            \text{Average TAT} & = \frac{45 + 50 + 26 + 29}{4} = 37.5 \\
            \text{Average WT}  & = \frac{25 + 35 + 16 + 24}{4} = 25   \\
            \text{Average RT}  & = \frac{0 + 10 + 20 + 30}{4} = 15
        \end{align*}
    \end{minipage}

    \rule{\textwidth}{0.5pt}

    \textbf{4. Shortest Time to Completion First (STCF)}

    \begin{minipage}[t]{0.48\textwidth}
        Execution order:
        \begin{itemize}
            \item 0-4: $P_2$ runs (rem 11)
            \item 4-6: $P_3$ runs (rem 8)
            \item 6-11: $P_4$ runs (done)
            \item 11-21: $P_3$ runs (done)
            \item 21-35: $P_2$ resumes (done)
            \item 35-55: $P_1$ runs (done)
        \end{itemize}

        Response times:
        \begin{itemize}
            \item $P_1$: 21
            \item $P_2$: 0
            \item $P_3$: 4
            \item $P_4$: 6
        \end{itemize}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{center}
            \begin{tabular}{@{} l c c c c @{}}
                \toprule
                Process & CT & TAT & WT & RT \\
                \midrule
                $P_1$   & 55 & 55  & 35 & 21 \\
                $P_2$   & 35 & 35  & 20 & 0  \\
                $P_3$   & 21 & 17  & 7  & 4  \\
                $P_4$   & 11 & 5   & 0  & 6  \\
                \bottomrule
            \end{tabular}
        \end{center}

        \begin{align*}
            \text{Average TAT} & = \frac{55 + 35 + 17 + 5}{4} = 28  \\
            \text{Average WT}  & = \frac{35 + 20 + 7 + 0}{4} = 15.5 \\
            \text{Average RT}  & = \frac{21 + 0 + 4 + 6}{4} = 7.75
        \end{align*}
    \end{minipage}

\end{examplebox}

\pagebreak
\subsection{Concurrency}
A cooperating process is one that can affect or be affected by another process that is executing on the system.

Threads are prime examples of this: we can think of them as a single process with multiple points of execution. They share program code and, crucially, data.

In this section, we consider the problems that occur then one or more threads try to access the same data, and we look at potential solutions.

A classic data inconsistency problem is the so-called “Race Condition”,


A Race Condition (also called a data race) is one where the result depends on the order in which instructions are executed.

For a single-thread process, this is predetermined.

But for multi-threaded processes, we do not have control over the order in which individual threads execute their instructions.

\begin{examplebox}{}{}
    Two cooperating process called $P_1$ and $P_2$ share the variable count. At various times during execution either may increment or decrement count. \\[2ex]

    The machine usually implements an increment as follows:
    \begin{itemize}
        \item 1. Load the value of count into a register: R1 = count
        \item 2. Add 1 to the contents of the register: R1 = R1 + 1
        \item 3. Overwrite the contents of count with the contents of the register: count = R1.
    \end{itemize}
    A decrement would be implemented as
    \begin{itemize}
        \item  1. load the value of count into a register: R2 = count
        \item  2. subtract 1 from the contents of the reg: R2 = R2 - 1
        \item 3. save the contents of the register as count: count = R2
    \end{itemize}
    Suppose the value of count is 5. If P1 executes an increment and P2 executes a decrement, then the value of count should still be 5. Unless the individual operations happen in the following order...
    $$
        \begin{array}{rlrl}
            P_1 \text{ executes} & \text{REG}_1 = \text{count}     & \quad \text{REG}_1 = 5 \\
            P_1 \text{ executes} & \text{REG}_1 = \text{REG}_1 + 1 & \quad \text{REG}_1 = 6 \\
            P_2 \text{ executes} & \text{REG}_2 = \text{count}     & \quad \text{REG}_2 = 5 \\
            P_2 \text{ executes} & \text{REG}_2 = \text{REG}_2 - 1 & \quad \text{REG}_2 = 4 \\
            P_1 \text{ executes} & \text{count} = \text{REG}_1     & \quad \text{count} = 6 \\
            P_2 \text{ executes} & \text{count} = \text{REG}_2     & \quad \text{count} = 4 \\
        \end{array}
    $$
    We arrive at the wrong state because we allowed both threads to manipulate the variable count at the same time. Since the outcome depends on the order in which each operation takes place, we have a race condition.
\end{examplebox}
\subsection{Critical Sections}
\begin{definitionbox}
    A critical section is a piece of code that accesses a shared variable (or more generally, a shared resource) and must not be concurrently executed by more than one thread.
\end{definitionbox}
The example given above  shows that multiple threads executing the same code can result in a race condition, that is an example of a critical section.
\end{document}