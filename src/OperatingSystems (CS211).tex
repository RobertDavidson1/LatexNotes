\documentclass[a4paper, 10pt]{article}
\input{preamble.sty}
\input{macros.sty}
\usepackage{listings}
\usepackage[hypcap=false]{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}


% 2) Adjust itemize settings globally:
\setlist[itemize]{
  leftmargin=2em,   % Indent from left
  itemsep=-0.4em,    % Vertical spacing between bullets
  topsep=0.5em      % Vertical space at the start of the list
}

\definecolor{commentgreen}{rgb}{0,0.5,0}
\definecolor{keywordsblue}{rgb}{0,0,0.8}
\definecolor{stringspurple}{rgb}{0.58,0,0.82}
\lstdefinestyle{cStyle}{
    language=C,
    columns=fullflexible,            % Better handling of spaces & tabs
    tabsize=4,
    keepspaces=true,
    showstringspaces=false,          % Do not underline string spaces
    numbersep=5pt,
    numbers=left,                    % Line numbers on the left
    stepnumber=1,
    basicstyle=\ttfamily\small,      % Base font style
    keywordstyle=\bfseries\color{keywordsblue},
    commentstyle=\itshape\color{commentgreen},
    stringstyle=\color{stringspurple},
    frame=single,                    % (Optional) draws a frame around the code
    breaklines=true,                 % Automatic line breaking
    breakatwhitespace=false
}

\title{
\textbf{CS211: Programing For Operating Systems} \\ 
}

\author{
Robert Davidson
}     
\date{}       

\begin{document}

\maketitle
\pagebreak

\tableofcontents
\pagebreak
\subsection*{Useful headers}
\begin{itemize}
    \item \texttt{stdio.h} : Standard input/output library
    \item \texttt{stdlib.h} : Standard library
    \item  \texttt{string.h} : String manipulation functions (strncpy, strcat, strcmp, strstr, strlen)
\end{itemize}

\pagebreak
\section{Intro to C}

It is a very small language and relies heavily on libraries
The compiler must be told in advance how these functions should be used. So before the compilation process, the \textbf{preprocessor} is run to include the function prototypes The compiler then compiles the code into an object file.

\subsection{Hello World}
\begin{lstlisting}[style=cStyle, caption={Hello World in C}]
    #include <stdio.h>
    int main(){
        printf("Hello World\n");
        return 0;
    }
    \end{lstlisting}
\begin{itemize}
    \item \textbf{Line 1} : \texttt{\#include <stdio.h>} is a preprocessor directive that tells the compiler to include the standard input/output library. This library contains the \texttt{printf} function.
    \item In C almost every line it either preprocessor directive, variable declaration, or a function call.
    \item C uses curly braces to delimit blocks of code and semicolons to terminate statements.
    \item \textbf{Line 4}: In our case, we assume main is called by the Operating System, so return 0 is used to indicate that the program has run successfully.
\end{itemize}

\subsection{Variables}
In C all variables must be declared before they are used. The declaration should have a type; telling the compiler what sort of data the variable will hold. The types of variables are:
\begin{itemize}
    \item \textbf{int} : Integer (1, 2, 3, 4, 5, ...)
    \item \textbf{float} : Floating-point number (7 decimal digits)
    \item \textbf{double} : Double-precision floating-point number (15 decimal digits)
    \item \textbf{char} : Character (a, b, c, ...)
    \item \textbf{void} : No type  (used for functions that do not return a value)
\end{itemize}

We can Also declare arrays as follows:
\begin{lstlisting}[style=cStyle, caption={Declaring Arrays}]
    int arr[5]; // Array of 5 integers
    char name[10]; // Array of 10 characters
\end{lstlisting}
To access the first element of arr we can do \texttt{arr[0]}
\subsection{An Example}
\begin{lstlisting}[style=cStyle, caption={Example of Variables}]
    int d=-101;
    float f=1.23456;
    char c='a';
    printf("Values of d, f, c are: %d, %f, %c\n", d, f ,c );
\end{lstlisting}
\textbf{Explanation:} In this case, \texttt{\%d} is a placeholder for an integer, \texttt{\%f} is a placeholder for a float, and \texttt{\%c} is a placeholder for a character.

\subsection{Operators}

\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description    & Example         \\
        \hline
        +        & Addition       & \texttt{a + b}  \\
        \hline
        -        & Subtraction    & \texttt{a - b}  \\
        \hline
        *        & Multiplication & \texttt{a * b}  \\
        \hline
        /        & Division       & \texttt{a / b}  \\
        \hline
        \%       & Modulus        & \texttt{a \% b} \\
        \hline
    \end{tabular}
    \captionof{table}{Arithmetic Operators}
\end{minipage}
\hfill
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description         & Example          \\
        \hline
        =        & Assignment          & \texttt{a = b}   \\
        \hline
        +=       & Add and assign      & \texttt{a += b}  \\
        \hline
        -=       & Subtract and assign & \texttt{a -= b}  \\
        \hline
        *=       & Multiply and assign & \texttt{a *= b}  \\
        \hline
        /=       & Divide and assign   & \texttt{a /= b}  \\
        \hline
        \%=      & Modulus and assign  & \texttt{a \%= b} \\
        \hline
        ++       & Increment           & \texttt{a++}     \\
        \hline
        --       & Decrement           & \texttt{a--}     \\
        \hline
    \end{tabular}
    \captionof{table}{Assignment and Arithmetic Assignment Operators}
\end{minipage}

\vspace{1em}
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description      & Example         \\
        \hline
        ==       & Equal            & \texttt{a == b} \\
        \hline
        !=       & Not Equal        & \texttt{a != b} \\
        \hline
        >        & Greater          & \texttt{a > b}  \\
        \hline
        <        & Less             & \texttt{a < b}  \\
        \hline
        >=       & Greater or Equal & \texttt{a >= b} \\
        \hline
        <=       & Less or Equal    & \texttt{a <= b} \\
        \hline
    \end{tabular}
    \captionof{table}{Relational Operators}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description & Example           \\
        \hline
        \&\&     & Logical AND & \texttt{a \&\& b} \\
        \hline
        ||       & Logical OR  & \texttt{a || b}   \\
        \hline
        !        & Logical NOT & \texttt{!a}       \\
        \hline
    \end{tabular}
    \captionof{table}{Logical Operators}
\end{minipage}





\subsection{Control Structure}
\begin{lstlisting}[style=cStyle, caption={If-Else}]
    int a = 10;
    if(a > 10){
            printf("a is greater than 10\n");
        }else if(a == 10){
            printf("a is equal to 10\n");
        }else{
    printf("a is less than 10\n");
    }
    \end{lstlisting}
Logical opeators, \texttt{\&\&} and \texttt{||} can be used to make more complex conditions.
\begin{lstlisting}[style=cStyle, caption={Complex If-Else}]
    if(a > 10 && a < 20){
        printf("a is between 10 and 20\n");
    }
    \end{lstlisting}
\subsubsection{For loop}
\texttt{for(initial val; continuation condition; increment/decrement)\{...\}}

\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
for(int i = 0; i < 10; i++){
    printf("i is %d\n", i);
}
\end{lstlisting}
\pagebreak
\subsubsection{While loop}
\texttt{while(expression)\{...\}}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
while(i < 10){
    printf("i is %d\n", i);
    i++;
}
\end{lstlisting}
\subsubsection{Do While loop}
\texttt{do\{...\}while(expression);}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
do{
    printf("i is %d\n", i);
    i++;
}while(i < 10);
\end{lstlisting}

\subsection{Output}
\texttt{printf()} is used to print formatted output to the screen. It is a variadic function, meaning it can take any number of arguments. The first argument is a format string, followed by the values to be printed.\\[2ex]
The format string may contain a number of escape characters, represented by a backslash. Some of the most common escape characters are:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Sequence                               & Description                                  \\
        \hline
        \texttt{\textbackslash a}              & Produces a beep or flash                     \\
        \hline
        \texttt{\textbackslash b}              & Moves cursor to last column of previous line \\
        \hline
        \texttt{\textbackslash f}              & Moves cursor to start of next page           \\
        \hline
        \texttt{\textbackslash n}              & New line                                     \\
        \hline
        \texttt{\textbackslash r}              & Carriage return                              \\
        \hline
        \texttt{\textbackslash t}              & Tab                                          \\
        \hline
        \texttt{\textbackslash v}              & Vertical tab                                 \\
        \hline
        \texttt{\textbackslash \textbackslash} & Prints a backslash                           \\
        \hline
        \texttt{\textbackslash '}              & Prints a single quote                        \\
        \hline
    \end{tabular}
\end{center}
A conversion character is a letter that follows a \texttt{\%} and tells \texttt{printf()} to display the value stored in the corresponding variable. Some of the most common conversion characters are:
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Specifier                    & Description                                  \\
        \hline
        \texttt{\%c}                 & Single character (char)                      \\
        \hline
        \texttt{\%d} or \texttt{\%i} & Decimal integer (int)                        \\
        \hline
        \texttt{\%e} or \texttt{\%E} & Floating-point (scientific notation)         \\
        \hline
        \texttt{\%f}                 & Floating-point value (float)                 \\
        \hline
        \texttt{\%g} or \texttt{\%G} & Same as \%e/\%E or \%f, whichever is shorter \\
        \hline
        \texttt{\%s}                 & String (char array)                          \\
        \hline
        \texttt{\%u}                 & Unsigned int                                 \\
        \hline
        \texttt{\%x}                 & Hexadecimal integer                          \\
        \hline
        \texttt{\%p}                 & Pointer (memory address)                     \\
        \hline
        \texttt{\%\%}                & Prints the \% character                      \\
        \hline
    \end{tabular}
\end{center}
\pagebreak
\subsection{Input}
\texttt{scanf()} reads input from standat input, format it, as directed by a conversion character and store the address of a specified variable.
\begin{lstlisting}[style=cStyle, caption={Reading an integer}]
    int number; 
    char letter; 
    printf("Enter a number and a char: ");
    scanf("%d %c", &number, &letter);

    printf("You entered: %d and %c\n", number, letter);
\end{lstlisting}
\begin{itemize}
    \item The scan \texttt{scanf()} returns an integer equal to the number of successfull conversions made.
    \item There is related function \texttt{fscanf()} that reads from a file. \texttt{scanf()} is really just a wrapper for \texttt{fscanf()} that treats the keyboard as a file.
    \item There are other useful functions for readint the standard input stream: \texttt{getchar()} and \texttt{gets()}.
\end{itemize}
\begin{lstlisting}[style=cStyle, caption={Check for no input}]
    int number;
    printf("Enter a number between 1 and 30: ");
    scanf("%d", &number);

    while ((number<1) || (number>30))
    {
        printf("Invalid number. Please enter a number between 1 and 30: ");
        scanf("%d", &number);
    }
\end{lstlisting}

\subsection{Functions}
\begin{definitionbox}[Protype and Definition]
    \textbf{Protype :} A function prototype is a declaration of a function that tells the compiler what the function looks like. It includes the function name, return type, and parameter types. The prototype must be declared before the function is called.\\[2ex]
    \textbf{Definition :} A function definition is the actual implementation of the function. It includes the function name, return type, parameter types, and the body of the function. The definition must be declared after the function is called.
\end{definitionbox}

\subsection{Call-by-Value and Pointers}
In C is it important to distuinguish between a variable and the value stored in it. A variable has a location in memory. The value of the variable is stored in that location. For example:
\begin{lstlisting}[style=cStyle]
int i = 10;
\end{lstlisting}
tells the system to allocate a location in memory to store the value 10. The variable \texttt{i} is a pointer to that location in memory. One of the distuinguihing features of C is it we can manipulate the memory address of the variable almost as easily as we can manipulate the value stored in it.
\begin{definitionbox}[Pointers]
    \begin{itemize}
        \item if \texttt{i} is a variable, then \texttt{\&i} is a pointer to the location in memory where the value of \texttt{i} is stored.
        \item The declaration \texttt{int *p;} creates a variable \texttt{p} that can store the memory address of an integer. The \texttt{*} indicates that \texttt{p} is a pointer to an integer.
        \item If a memory address is stored in the variable \texttt{p}, then \texttt{*p} is the value stored at that address.
    \end{itemize}
\end{definitionbox}
\pagebreak
\subsection{Characters}
\begin{conceptbox}[Character representation]
    In C, a character is just an unsigned integer. Each character is represented by an integer between 0 and 127.
\end{conceptbox}

\begin{minipage}{0.45\textwidth}
    \textbf{Printing characters:}

    \begin{itemize}
        \item \texttt{printf("\&c", c)}
        \item \texttt{putchar(c)}
    \end{itemize}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \textbf{Reading characters:}
    \begin{itemize}
        \item \texttt{scanf("\&c", c)}
        \item \texttt{c = getchar()}
    \end{itemize}
\end{minipage}
\subsection{Strings}
\begin{conceptbox}[String representation]
    C does not have a string data type. Instead it uses arrays of type char to represent strings. For example if we make a declaration:
    $$\texttt{char greeting[20]="Hello. How are you?";}$$
    the system stores each character as an element of the array greeting.
\end{conceptbox}
\subsubsection{String Functions}
Useful functions defined in \texttt{string.h}: \\[2ex]
$$\texttt{char *strncp(char *dest, char *src, int n)} $$
Copies at most \texttt{n} characters from \texttt{src} to \texttt{dest}. The advantage of this is that we don't copy more chatavyers to \texttt{dest} than it can hold (prevents buffer overflow). \texttt{strncpy()} does not append a null character to the end of the string, so we need to do that manually. \\[2ex]
$$\texttt{char *strcat(char *dest, char *src)}$$
Concatenates the string \texttt{src} to the end of the string \texttt{dest}. The destination string must be large enough to hold the concatenated result. \texttt{strcat()} appends a null character to the end of the string. \\[2ex]
$$\texttt{int strcmp(char *str1, char *str2)}$$
Compares two strings annd returns an intger:
\begin{itemize}
    \item 0 if the strings are equal
    \item A negative integer if \texttt{str1} comes first alphabetically
    \item A negative integer if \texttt{str2} comes first alphabetically
\end{itemize}
$$\texttt{char *strstr(char *haystack, char *needle)} $$
Searches for the first occurrence of the string \texttt{needle} in the string \texttt{haystack}. If found, it returns a pointer to the first occurrence of \texttt{needle} in \texttt{haystack}. If not found, it returns NULL. \\[2ex]
$$\texttt{int strlen(char *str)}$$
Returns the length of the string \texttt{str} (not including the null character).

\pagebreak
\subsection*{1.11 Strings (Continued)}
\subsubsection{String Output}
We know how to use \texttt{printf()} to print strings:
\begin{itemize}
    \item \texttt{printf("\%s\%s$\backslash$n, "Good Morning ", name);}
    \item \texttt{printf("\%s\%8s$\backslash$n", "Good Morning ", name);}
\end{itemize}
The second example, the field width specifier is given. This causes the string to be padded so it takes up a total of 8 spaces. If the string is shorter than 8 characters, it is padded with spaces on the left. If the string is longer than 8 characters, it is printed as is.

\subsubsection{String Input}
\begin{itemize}
    \item \texttt{scanf("\%s", name);} reads the next "word" from th input stream and stores it in the array \texttt{name}. A "word" is defined as a sequence of characters separated without a space, tab, or newline. The string is terminated with a null character.
    \item \texttt{getchar(name);} to get more control of the input in a loop
    \item \texttt{gets(string);} reads a line input and stores it all except the newline character. The string is terminated with a null character. \texttt{gets()} is not safe to use because it does not check the length of the input string. If the input string is longer than the array, it will cause a buffer overflow and overwrite other data in memory.
    \item \texttt{fgets(string, n, stdin);} reads in a line of text from the keyboard (standard input stream) and stores at most \texttt{n} characters in the array \texttt{string}. The string is terminated with a null character. If the input string is longer than \texttt{n}, it will be truncated and the rest will be discarded. \texttt{fgets()} is safer to use than \texttt{gets()} because it checks the length of the input string.
\end{itemize}
\section{Arrays}
\section{Arrays}
To declare a $3 \times 4$ matrix of floats, we write \texttt{float a[3][4];}. So:
$$\begin{bmatrix}
        a[0][0] & a[0][1] & a[0][2] & a[0][3] \\
        a[1][0] & a[1][1] & a[1][2] & a[1][3] \\
        a[2][0] & a[2][1] & a[2][2] & a[2][3]
    \end{bmatrix}
$$
In general, an $n \times m$ array is declared as \texttt{float a[n][m];}. The first index is the row number and the second index is the column number. The first element of the array is \texttt{a[0][0]} and the last element is \texttt{a[n-1][m-1]}. \\[2ex]
If a has the line \texttt{int [a][4];} then the system creats three arrays, each of length four. More precisely, it:
\begin{itemize}
    \item declares 3 pointers to type \texttt{int}: \texttt{a[0]}, \texttt{a[1]}, and \texttt{a[2]}
    \item space for storing an integer is allocated to each of addresses \texttt{a[0], a[0]+1, a[0]+2, a[0]+3, a[1], a[1]+1}, $\dots$, \texttt{a[2]+3}
\end{itemize}
This mean is if \texttt{a[][]} is declared as a two-dimensional $3 \times 4$ array, then the following are equivalent:
\begin{itemize}
    \item \texttt{a[1][2]}
    \item \texttt{*(a[1]+2)}
    \item \texttt{*(*(a+1)+2)}
    \item \texttt{*(\&a[0][0]+4+2)}
\end{itemize}
\pagebreak
\subsection{Explanation of Array Element Access in C}

\subsubsection*{\texttt{a[1][2]}}
This is the standard way to access a two-dimensional array element. It directly fetches the element in the second row (index 1) and the third column (index 2).

\subsubsection*{\texttt{*(a[1]+2)}}
\begin{itemize}
    \item \texttt{a[1]} yields the second row, which decays to a pointer to its first element (i.e., equivalent to \texttt{\&a[1][0]}).
    \item Adding \texttt{2} moves the pointer two elements forward in that row.
    \item The dereference operator \texttt{*} then accesses the element at that position, which is \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(*(a+1)+2)}}
\begin{itemize}
    \item \texttt{a+1} moves the pointer from the first row to the second row.
    \item \texttt{*(a+1)} dereferences that pointer to yield the address of the first element of the second row (again, equivalent to \texttt{a[1]}).
    \item Adding \texttt{2} moves to the third element in that row, and the outer \texttt{*} fetches its value---again, \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(\&a[0][0]+4+2)}}
\begin{itemize}
    \item \texttt{\&a[0][0]} gets the address of the very first element of the array.
    \item Since the array is stored in contiguous memory, pointer arithmetic treats it as a flat sequence. Adding \texttt{4+2} (i.e., 6) moves the pointer to the 7th element in that sequence.
    \item If the layout of the array is such that the element \texttt{a[1][2]} is the 7th element (this is true, for example, if the row length is at least 3), then dereferencing this pointer retrieves \texttt{a[1][2]}.
\end{itemize}

\section{Files}
Taking an input from a file is not much different than taking input from a keyboard. All we do is:
\begin{itemize}
    \item Declare an identifier of type \texttt{FILE} to hold the file pointer.
    \item Open the file (\texttt{fopen()})
    \item Read the file
    \item Close the file (\texttt{fclose()})
\end{itemize}
\subsection{Declaring a file indentifier:}
$$\texttt{FILE *datafile;}$$
The datafile is now a pointer we can associate with a file. The \texttt{FILE} type is defined in the \texttt{stdio.h} library.
\subsection{Opening a file:}
$$\texttt{fileptr = fopen(char *filename, char *mode);}$$
The \texttt{fopen()} is a function that is use for file opening. It takes two arguments: the name of a file and the mode it will operrate in. A file pointer is returned. The mode can be:
\begin{itemize}
    \item \texttt{r} : read (open an existing file for reading)
    \item \texttt{w} : write (overrwite the file or create a new one)
    \item \texttt{a} : append (add to the end of the file)
\end{itemize}
\subsection{Closing a File}
$$\texttt{fclose(fileptr);}$$
Once a file is “closed” we can no longer read from it or write to it, unless
we open it again. If we don’t do this, the file will still be closed when the
program terminates. But until then, no other program on the same node
(computer) can work with the file, and it might but be fully written to
storage
\subsection{Reading from a file}
$$\texttt{fgets(char *str, int n, FILE *fileptr);}$$
reads in a line of text from the fileptr stream and stores at most n
characters in array sting. The mew line character is stored.
If the string can’t be read, because we have reached the end of the file,
then NULL is returned.
$$\texttt{fgetc(FILE *fileptr);}$$
reads the next character in the file and stores it in the char variable c. If
the end of the file has been reached, EOF is returned.
$$\texttt{fscanf(FILE *fileptr, char *format, ...);}$$
reads formatted input from the file. The format string is similar to the
one used in \texttt{printf()}
\subsection{Navigating a file}
Each time a character is reader from the input stream, a counter associated with the stream is incremented.
$$\texttt{rewind(FILE *fileptr);}$$
sets the indicator to the start of the file
$$\texttt{ftell(FILE *fileptr);}$$
is used to check the current value of the file position indivator in the form of a long int.
$$\texttt{fseek(FILE *fileptr, long offset, int place);}$$
the value of offset is the amount the indicator will be changed by, while placce is one of:
\begin{itemize}
    \item \texttt{SEEK\_SET(0)} : the start of the file
    \item \texttt{SEEK\_CUR(1)} : the current position in the file
    \item \texttt{SEEK\_END(2)} : the end of the file
\end{itemize}
\subsection{Writing to a file}
To write to a file, we declare a file pointer:
$$\texttt{FILE *outfile;}$$
and open a new file in write mode:
$$\texttt{outfile = fopen("myList.txt", "w");}$$
to write to the file, we use one of:
\begin{itemize}
    \item \texttt{fprintf(outfile, char *format, ...);} : works like \texttt{printf()} except its first argument is a file pointer
    \item \texttt{fputs(char *str, FILE *fileptr);} : writes the string str to the file pointed to by fileptr, without its trailing '\texttt{\textbackslash 0}' character. The string is not formatted.
    \item \texttt{fputc(int c, FILE *fileptr);} : writes the character c to the file pointed to by fileptr. The character is not formatted.
\end{itemize}
\pagebreak
\subsection{Issues concerining the use of files in C, we should be aware of:}
\begin{itemize}
    \item There are 6 modes a file can have: \texttt{r, w, a, r+, w+, a+}
    \item To open a binary file, also add a \texttt{b} to the mode. For example, \texttt{rb} opens a file for reading in binary mode.
    \item \texttt{freopen()} attaches a new file to an existing file pointer. It is used to redirect the standard input or output to a file. For example, \texttt{freopen("myList.txt", "w", stdout);} redirects the standard output to the file \texttt{myList.txt}. This means that any output that would normally go to the screen will now go to the file.
    \item \texttt{tmpfile()} open a tempory file in binary read/write and is automatically deleted when closed or when the program terminates
    \item \texttt{fflush(fileptr);} flushes the output buffer of the file pointer. This means that any data that has been buffered but not yet written to the file will be written to the file.
    \item \texttt{remove("myList.txt");} deletes the file \texttt{myList.txt} from the disk.
    \item \texttt{rename("myList.txt", "myList2.txt");} renames the file \texttt{myList.txt} to \texttt{myList2.txt}. If the new name already exists, it will be overwritten.
    \item \texttt{int feof(FILE *fileptr);} returns a non-zero value if the end of the file has been reached. It is used to check if we have reached the end of the file while reading it.
\end{itemize}

\section{The Process}
$$\textbf{"A process is a running program."}$$
The operating system gives the impression many programs are running at the same time, but in reality, only one program is running at a time. This is made possible by abstracting the the concept of a running program as a process.
\begin{conceptbox}[Every process has]
    \begin{itemize}
        \item \textbf{The process text:} the program code
        \item \textbf{The program counter:} the address of the next instruction to be executed
        \item \textbf{The process stack:}  temporary data, local variables, function parameters, return addresses
        \item \textbf{The data section:}  global variables
    \end{itemize}
\end{conceptbox}
A process is not just a program - if two users run the same program at the same time, they create different processes. Each process has its own memory space, so they do not interfere with each other. A program is a passive entity, while a process is an active / dynamic entity.
\begin{conceptbox}[Operations OS must perform on a process]
    \begin{itemize}
        \item \textbf{Create} a new process (open a new program)
        \item \textbf{Terminate / Destory} a process (close a program)
        \item \textbf{Wait} or pause a process until some event occurs (e.g. waiting for user input)
        \item \textbf{Supsend and Resume} similar to wait but more explicit
        \item \textbf{Status}  report info about a process (e.g. how much memory it is using, how long it has been running, etc.)
    \end{itemize}
\end{conceptbox}


\end{document}