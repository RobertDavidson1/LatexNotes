\documentclass[a4paper, 10pt]{article}
\input{preamble.sty}
\input{macros.sty}
\usepackage{listings}
\usepackage[hypcap=false]{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}


% 2) Adjust itemize settings globally:
\setlist[itemize]{
  leftmargin=2em,   % Indent from left
  itemsep=-0.4em,    % Vertical spacing between bullets
  topsep=0.5em      % Vertical space at the start of the list
}

\definecolor{commentgreen}{rgb}{0,0.5,0}
\definecolor{keywordsblue}{rgb}{0,0,0.8}
\definecolor{stringspurple}{rgb}{0.58,0,0.82}
\lstdefinestyle{cStyle}{
    language=C,
    columns=fullflexible,            % Better handling of spaces & tabs
    tabsize=4,
    keepspaces=true,
    showstringspaces=false,          % Do not underline string spaces
    numbersep=5pt,
    numbers=left,                    % Line numbers on the left
    stepnumber=1,
    basicstyle=\ttfamily\small,      % Base font style
    keywordstyle=\bfseries\color{keywordsblue},
    commentstyle=\itshape\color{commentgreen},
    stringstyle=\color{stringspurple},
    frame=single,                    % (Optional) draws a frame around the code
    breaklines=true,                 % Automatic line breaking
    breakatwhitespace=false
}

\title{
\textbf{CS211: Programing For Operating Systems} \\ 
}

\author{
Robert Davidson
}     
\date{}       

\begin{document}

\maketitle
\pagebreak

\tableofcontents
\pagebreak
\section{Intro to C}

It is a very small language and relies heavily on libraries
The compiler must be told in advance how these functions should be used. So before the compilation process, the \textbf{preprocessor} is run to include the function prototypes The compiler then compiles the code into an object file.

\subsection{Hello World}
\begin{lstlisting}[style=cStyle, caption={Hello World in C}]
    #include <stdio.h>
    int main(){
        printf("Hello World\n");
        return 0;
    }
    \end{lstlisting}
\begin{itemize}
    \item \textbf{Line 1} : \texttt{\#include <stdio.h>} is a preprocessor directive that tells the compiler to include the standard input/output library. This library contains the \texttt{printf} function.
    \item In C almost every line it either preprocessor directive, variable declaration, or a function call.
    \item C uses curly braces to delimit blocks of code and semicolons to terminate statements.
    \item \textbf{Line 4}: In our case, we assume main is called by the Operating System, so return 0 is used to indicate that the program has run successfully.
\end{itemize}

\subsection{Variables}
In C all variables must be declared before they are used. The declaration should have a type; telling the compiler what sort of data the variable will hold. The types of variables are:
\begin{itemize}
    \item \textbf{int} : Integer (1, 2, 3, 4, 5, ...)
    \item \textbf{float} : Floating-point number (7 decimal digits)
    \item \textbf{double} : Double-precision floating-point number (15 decimal digits)
    \item \textbf{char} : Character (a, b, c, ...)
    \item \textbf{void} : No type  (used for functions that do not return a value)
\end{itemize}

We can Also declare arrays as follows:
\begin{lstlisting}[style=cStyle, caption={Declaring Arrays}]
    int arr[5]; // Array of 5 integers
    char name[10]; // Array of 10 characters
\end{lstlisting}
To access the first element of arr we can do \texttt{arr[0]}
\subsection{An Example}
\begin{lstlisting}[style=cStyle, caption={Example of Variables}]
    int d=-101;
    float f=1.23456;
    char c='a';
    printf("Values of d, f, c are: %d, %f, %c\n", d, f ,c );
\end{lstlisting}
\textbf{Explanation:} In this case, \texttt{\%d} is a placeholder for an integer, \texttt{\%f} is a placeholder for a float, and \texttt{\%c} is a placeholder for a character.

\subsection{Operators}

\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description    & Example         \\
        \hline
        +        & Addition       & \texttt{a + b}  \\
        \hline
        -        & Subtraction    & \texttt{a - b}  \\
        \hline
        *        & Multiplication & \texttt{a * b}  \\
        \hline
        /        & Division       & \texttt{a / b}  \\
        \hline
        \%       & Modulus        & \texttt{a \% b} \\
        \hline
    \end{tabular}
    \captionof{table}{Arithmetic Operators}
\end{minipage}
\hfill
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description         & Example          \\
        \hline
        =        & Assignment          & \texttt{a = b}   \\
        \hline
        +=       & Add and assign      & \texttt{a += b}  \\
        \hline
        -=       & Subtract and assign & \texttt{a -= b}  \\
        \hline
        *=       & Multiply and assign & \texttt{a *= b}  \\
        \hline
        /=       & Divide and assign   & \texttt{a /= b}  \\
        \hline
        \%=      & Modulus and assign  & \texttt{a \%= b} \\
        \hline
        ++       & Increment           & \texttt{a++}     \\
        \hline
        --       & Decrement           & \texttt{a--}     \\
        \hline
    \end{tabular}
    \captionof{table}{Assignment and Arithmetic Assignment Operators}
\end{minipage}

\vspace{1em}
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description      & Example         \\
        \hline
        ==       & Equal            & \texttt{a == b} \\
        \hline
        !=       & Not Equal        & \texttt{a != b} \\
        \hline
        >        & Greater          & \texttt{a > b}  \\
        \hline
        <        & Less             & \texttt{a < b}  \\
        \hline
        >=       & Greater or Equal & \texttt{a >= b} \\
        \hline
        <=       & Less or Equal    & \texttt{a <= b} \\
        \hline
    \end{tabular}
    \captionof{table}{Relational Operators}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description & Example           \\
        \hline
        \&\&     & Logical AND & \texttt{a \&\& b} \\
        \hline
        ||       & Logical OR  & \texttt{a || b}   \\
        \hline
        !        & Logical NOT & \texttt{!a}       \\
        \hline
    \end{tabular}
    \captionof{table}{Logical Operators}
\end{minipage}





\subsection{Control Structure}
\begin{lstlisting}[style=cStyle, caption={If-Else}]
    int a = 10;
    if(a > 10){
            printf("a is greater than 10\n");
        }else if(a == 10){
            printf("a is equal to 10\n");
        }else{
    printf("a is less than 10\n");
    }
    \end{lstlisting}
Logical opeators, \texttt{\&\&} and \texttt{||} can be used to make more complex conditions.
\begin{lstlisting}[style=cStyle, caption={Complex If-Else}]
    if(a > 10 && a < 20){
        printf("a is between 10 and 20\n");
    }
    \end{lstlisting}
\subsubsection{For loop}
\texttt{for(initial val; continuation condition; increment/decrement)\{...\}}

\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
for(int i = 0; i < 10; i++){
    printf("i is %d\n", i);
}
\end{lstlisting}
\pagebreak
\subsubsection{While loop}
\texttt{while(expression)\{...\}}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
while(i < 10){
    printf("i is %d\n", i);
    i++;
}
\end{lstlisting}
\subsubsection{Do While loop}
\texttt{do\{...\}while(expression);}
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
do{
    printf("i is %d\n", i);
    i++;
}while(i < 10);
\end{lstlisting}

\subsection{Output}
\texttt{printf()} is used to print formatted output to the screen. It is a variadic function, meaning it can take any number of arguments. The first argument is a format string, followed by the values to be printed.\\[2ex]
The format string may contain a number of escape characters, represented by a backslash. Some of the most common escape characters are:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Sequence                               & Description                                  \\
        \hline
        \texttt{\textbackslash a}              & Produces a beep or flash                     \\
        \hline
        \texttt{\textbackslash b}              & Moves cursor to last column of previous line \\
        \hline
        \texttt{\textbackslash f}              & Moves cursor to start of next page           \\
        \hline
        \texttt{\textbackslash n}              & New line                                     \\
        \hline
        \texttt{\textbackslash r}              & Carriage return                              \\
        \hline
        \texttt{\textbackslash t}              & Tab                                          \\
        \hline
        \texttt{\textbackslash v}              & Vertical tab                                 \\
        \hline
        \texttt{\textbackslash \textbackslash} & Prints a backslash                           \\
        \hline
        \texttt{\textbackslash '}              & Prints a single quote                        \\
        \hline
    \end{tabular}
\end{center}
A conversion character is a letter that follows a \texttt{\%} and tells \texttt{printf()} to display the value stored in the corresponding variable. Some of the most common conversion characters are:
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Specifier                    & Description                                  \\
        \hline
        \texttt{\%c}                 & Single character (char)                      \\
        \hline
        \texttt{\%d} or \texttt{\%i} & Decimal integer (int)                        \\
        \hline
        \texttt{\%e} or \texttt{\%E} & Floating-point (scientific notation)         \\
        \hline
        \texttt{\%f}                 & Floating-point value (float)                 \\
        \hline
        \texttt{\%g} or \texttt{\%G} & Same as \%e/\%E or \%f, whichever is shorter \\
        \hline
        \texttt{\%s}                 & String (char array)                          \\
        \hline
        \texttt{\%u}                 & Unsigned int                                 \\
        \hline
        \texttt{\%x}                 & Hexadecimal integer                          \\
        \hline
        \texttt{\%p}                 & Pointer (memory address)                     \\
        \hline
        \texttt{\%\%}                & Prints the \% character                      \\
        \hline
    \end{tabular}
\end{center}
\pagebreak
\subsection{Input}
\texttt{scanf()} reads input from standat input, format it, as directed by a conversion character and store the address of a specified variable.
\begin{lstlisting}[style=cStyle, caption={Reading an integer}]
    int number; 
    char letter; 
    printf("Enter a number and a char: ");
    scanf("%d %c", &number, &letter);

    printf("You entered: %d and %c\n", number, letter);
\end{lstlisting}
\begin{itemize}
    \item The scan \texttt{scanf()} returns an integer equal to the number of successfull conversions made.
    \item There is related function \texttt{fscanf()} that reads from a file. \texttt{scanf()} is really just a wrapper for \texttt{fscanf()} that treats the keyboard as a file.
    \item There are other useful functions for readint the standard input stream: \texttt{getchar()} and \texttt{gets()}.
\end{itemize}
\begin{lstlisting}[style=cStyle, caption={Check for no input}]
    int number;
    printf("Enter a number between 1 and 30: ");
    scanf("%d", &number);

    while ((number<1) || (number>30))
    {
        printf("Invalid number. Please enter a number between 1 and 30: ");
        scanf("%d", &number);
    }
\end{lstlisting}

\subsection{Functions}
\begin{definitionbox}[Protype and Definition]
    \textbf{Protype :} A function prototype is a declaration of a function that tells the compiler what the function looks like. It includes the function name, return type, and parameter types. The prototype must be declared before the function is called.\\[2ex]
    \textbf{Definition :} A function definition is the actual implementation of the function. It includes the function name, return type, parameter types, and the body of the function. The definition must be declared after the function is called.
\end{definitionbox}

\subsection{Call-by-Value and Pointers}
In C is it important to distuinguish between a variable and the value stored in it. A variable has a location in memory. The value of the variable is stored in that location. For example:
\begin{lstlisting}[style=cStyle]
int i = 10;
\end{lstlisting}
tells the system to allocate a location in memory to store the value 10. The variable \texttt{i} is a pointer to that location in memory. One of the distuinguihing features of C is it we can manipulate the memory address of the variable almost as easily as we can manipulate the value stored in it.
\begin{definitionbox}[Pointers]
    \begin{itemize}
        \item if \texttt{i} is a variable, then \texttt{\&i} is a pointer to the location in memory where the value of \texttt{i} is stored.
        \item The declaration \texttt{int *p;} creates a variable \texttt{p} that can store the memory address of an integer. The \texttt{*} indicates that \texttt{p} is a pointer to an integer.
        \item If a memory address is stored in the variable \texttt{p}, then \texttt{*p} is the value stored at that address.
    \end{itemize}
\end{definitionbox}
\pagebreak
\subsection{Characters}
\begin{conceptbox}[Character representation]
    In C, a character is just an unsigned integer. Each character is represented by an integer between 0 and 127.
\end{conceptbox}

\begin{minipage}{0.45\textwidth}
    \textbf{Printing characters:}

    \begin{itemize}
        \item \texttt{printf("\&c", c)}
        \item \texttt{putchar(c)}
    \end{itemize}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \textbf{Reading characters:}
    \begin{itemize}
        \item \texttt{scanf("\&c", c)}
        \item \texttt{c = getchar()}
    \end{itemize}
\end{minipage}
\subsection{Strings}
\begin{conceptbox}[String representation]
    C does not have a string data type. Instead it uses arrays of type char to represent strings. For example if we make a declaration:
    $$\texttt{char greeting[20]="Hello. How are you?";}$$
    the system stores each character as an element of the array greeting.
\end{conceptbox}
\subsubsection{String Functions}
Useful functions defined in \texttt{string.h}: \\[2ex]
\textbf{srncpy()} \\
\texttt{char *strncp(char *dest, char *src, int n)} \\
Copies at most \texttt{n} characters from \texttt{src} to \texttt{dest}. The advantage of this is that we don't copy more chatavyers to \texttt{dest} than it can hold (prevents buffer overflow). \texttt{strncpy()} does not append a null character to the end of the string, so we need to do that manually. \\[2ex]
\textbf{strcat()} \\
\texttt{char *strcat(char *dest, char *src)} \\
Concatenates the string \texttt{src} to the end of the string \texttt{dest}. The destination string must be large enough to hold the concatenated result. \texttt{strcat()} appends a null character to the end of the string. \\[2ex]
\textbf{strcmp()} \\
\texttt{int strcmp(char *str1, char *str2)} \\
Compares two strings annd returns an intger:
\begin{itemize}
    \item 0 if the strings are equal
    \item A negative integer if \texttt{str1} comes first alphabetically
    \item A negative integer if \texttt{str2} comes first alphabetically
\end{itemize}
\textbf{strstr()} \\
\texttt{char *strstr(char *haystack, char *needle)} \\
Searches for the first occurrence of the string \texttt{needle} in the string \texttt{haystack}. If found, it returns a pointer to the first occurrence of \texttt{needle} in \texttt{haystack}. If not found, it returns NULL. \\[2ex]
\textbf{strlen()} \\
\texttt{int strlen(char *str)} \\
Returns the length of the string \texttt{str} (not including the null character).



\end{document}