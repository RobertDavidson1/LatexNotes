\documentclass[a4paper, 10pt]{article}
\input{preamble.sty}
\input{macros.sty}
\usepackage{listings}
\usepackage[hypcap=false]{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}


% 2) Adjust itemize settings globally:
\setlist[itemize]{
  leftmargin=2em,   % Indent from left
  itemsep=-0.4em,    % Vertical spacing between bullets
  topsep=0.5em      % Vertical space at the start of the list
}

\definecolor{commentgreen}{rgb}{0,0.5,0}
\definecolor{keywordsblue}{rgb}{0,0,0.8}
\definecolor{stringspurple}{rgb}{0.58,0,0.82}
\lstdefinestyle{cStyle}{
    language=C,
    columns=fullflexible,            % Better handling of spaces & tabs
    tabsize=4,
    keepspaces=true,
    showstringspaces=false,          % Do not underline string spaces
    numbersep=5pt,
    numbers=left,                    % Line numbers on the left
    stepnumber=1,
    basicstyle=\ttfamily\scriptsize,      % Base font style
    keywordstyle=\bfseries\color{keywordsblue},
    commentstyle=\itshape\color{commentgreen},
    stringstyle=\color{stringspurple},
    frame=single,                    % (Optional) draws a frame around the code
    breaklines=true,                 % Automatic line breaking
    breakatwhitespace=false
}

\title{
\textbf{CS211: Programing For Operating Systems} \\ 
}

\author{
Robert Davidson
}     
\date{}       

\begin{document}

\maketitle
\pagebreak

\tableofcontents
\pagebreak

\section{Intro to C}
C is a compiled language, not an interpretive language. Meaning we need a program called a compiler to convert the code into machine code. The compiler is called \textbf{gcc} \\[2ex]
It is a \textbf{very small language and relies heavily on libraries}. The compiler must be told in advance how these functions should be used. So before the compilation process, the \textbf{preprocessor} is run to include the function prototypes The compiler then compiles the code into an object file.

\subsection{Variables}
In C, variables must be declared before they're used. Declarion should have a type to tell compiler what data the variable will hold
\begin{itemize}
    \item \textbf{int} : Integer (1, 2, 3, 4, 5, ...)
    \item \textbf{float} : Floating-point number (7 decimal digits)
    \item \textbf{double} : Double-precision floating-point number (15 decimal digits)
    \item \textbf{char} : Character (a, b, c, ...)
    \item \textbf{void} : No type  (used for functions that do not return a value)
\end{itemize}

\subsection{Operators}

\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description    & Example         \\
        \hline
        +        & Addition       & \texttt{a + b}  \\
        \hline
        -        & Subtraction    & \texttt{a - b}  \\
        \hline
        *        & Multiplication & \texttt{a * b}  \\
        \hline
        /        & Division       & \texttt{a / b}  \\
        \hline
        \%       & Modulus        & \texttt{a \% b} \\
        \hline
    \end{tabular}
    \captionof{table}{Arithmetic Operators}
\end{minipage}
\hfill
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description         & Example          \\
        \hline
        =        & Assignment          & \texttt{a = b}   \\
        \hline
        +=       & Add and assign      & \texttt{a += b}  \\
        \hline
        -=       & Subtract and assign & \texttt{a -= b}  \\
        \hline
        *=       & Multiply and assign & \texttt{a *= b}  \\
        \hline
        /=       & Divide and assign   & \texttt{a /= b}  \\
        \hline
        \%=      & Modulus and assign  & \texttt{a \%= b} \\
        \hline
        ++       & Increment           & \texttt{a++}     \\
        \hline
        --       & Decrement           & \texttt{a--}     \\
        \hline
    \end{tabular}
    \captionof{table}{Assignment and Arithmetic Assignment Operators}
\end{minipage}

\vspace{1em}
\begin{minipage}{0.50\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description      & Example         \\
        \hline
        ==       & Equal            & \texttt{a == b} \\
        \hline
        !=       & Not Equal        & \texttt{a != b} \\
        \hline
        >        & Greater          & \texttt{a > b}  \\
        \hline
        <        & Less             & \texttt{a < b}  \\
        \hline
        >=       & Greater or Equal & \texttt{a >= b} \\
        \hline
        <=       & Less or Equal    & \texttt{a <= b} \\
        \hline
    \end{tabular}
    \captionof{table}{Relational Operators}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Operator & Description & Example           \\
        \hline
        \&\&     & Logical AND & \texttt{a \&\& b} \\
        \hline
        ||       & Logical OR  & \texttt{a || b}   \\
        \hline
        !        & Logical NOT & \texttt{!a}       \\
        \hline
    \end{tabular}
    \captionof{table}{Logical Operators}
\end{minipage}

\pagebreak

\subsection{Control Flow}

\subsection{If Else}
\begin{lstlisting}[style=cStyle, caption={If-Else}]
int a = 10;
if(a > 10){
        printf("a is greater than 10\n");
    }else if(a == 10){
        printf("a is equal to 10\n");
    }else{
printf("a is less than 10\n");
}
\end{lstlisting}
Logical opeators, \texttt{\&\&} and \texttt{||} can be used to make more complex conditions.
\begin{lstlisting}[style=cStyle, caption={Complex If-Else}]
if(a > 10 && a < 20){
    printf("a is between 10 and 20\n");
}
\end{lstlisting}
\subsubsection*{For loop}
$$\texttt{for(initial val; continuation condition; increment/decrement)\{...\}}$$

\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
for(int i = 0; i < 10; i++){
    printf("i is %d\n", i);
}
\end{lstlisting}
\subsubsection*{While loop}
$$\texttt{while(expression)\{...\}}$$
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
while(i < 10){
    printf("i is %d\n", i);
    i++;
}
\end{lstlisting}
\subsubsection*{Do While loop}
$$\texttt{do\{...\}while(expression);}$$
\begin{lstlisting}[style=cStyle, caption={Print numbers from 0 to 9}]
int i = 0;
do{
    printf("i is %d\n", i);
    i++;
}while(i < 10);
\end{lstlisting}

\newpage

\subsection{Output}
\texttt{printf()} is used to print formatted output to the screen. It is a variadic function, meaning it can take any number of arguments. The first argument is a format string, followed by the values to be printed.\\[2ex]
The format string may contain a number of escape characters, represented by a backslash. Some of the most common escape characters are:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Sequence                               & Description                                  \\
        \hline
        \texttt{\textbackslash a}              & Produces a beep or flash                     \\
        \hline
        \texttt{\textbackslash b}              & Moves cursor to last column of previous line \\
        \hline
        \texttt{\textbackslash f}              & Moves cursor to start of next page           \\
        \hline
        \texttt{\textbackslash n}              & New line                                     \\
        \hline
        \texttt{\textbackslash r}              & Carriage return                              \\
        \hline
        \texttt{\textbackslash t}              & Tab                                          \\
        \hline
        \texttt{\textbackslash v}              & Vertical tab                                 \\
        \hline
        \texttt{\textbackslash \textbackslash} & Prints a backslash                           \\
        \hline
        \texttt{\textbackslash '}              & Prints a single quote                        \\
        \hline
    \end{tabular}
\end{center}
A conversion character is a letter that follows a \texttt{\%} and tells \texttt{printf()} to display the value stored in the corresponding variable. Some of the most common conversion characters are:
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Specifier                    & Description                                  \\
        \hline
        \texttt{\%c}                 & Single character (char)                      \\
        \hline
        \texttt{\%d} or \texttt{\%i} & Decimal integer (int)                        \\
        \hline
        \texttt{\%e} or \texttt{\%E} & Floating-point (scientific notation)         \\
        \hline
        \texttt{\%f}                 & Floating-point value (float)                 \\
        \hline
        \texttt{\%g} or \texttt{\%G} & Same as \%e/\%E or \%f, whichever is shorter \\
        \hline
        \texttt{\%s}                 & String (char array)                          \\
        \hline
        \texttt{\%u}                 & Unsigned int                                 \\
        \hline
        \texttt{\%x}                 & Hexadecimal integer                          \\
        \hline
        \texttt{\%p}                 & Pointer (memory address)                     \\
        \hline
        \texttt{\%\%}                & Prints the \% character                      \\
        \hline
    \end{tabular}
\end{center}

\subsection{Input}
\texttt{scanf()} reads input from standat input, format it, as directed by a conversion character and store the address of a specified variable.
\begin{lstlisting}[style=cStyle, caption={Reading an integer}]
    int number; 
    char letter; 
    printf("Enter a number and a char: ");
    scanf("%d %c", &number, &letter);

    printf("You entered: %d and %c\n", number, letter);
\end{lstlisting}
\begin{itemize}
    \item The scan \texttt{scanf()} returns an integer equal to the number of successfull conversions made.
    \item There is related function \texttt{fscanf()} that reads from a file. \texttt{scanf()} is really just a wrapper for \texttt{fscanf()} that treats the keyboard as a file.
    \item There are other useful functions for readint the standard input stream: \texttt{getchar()} and \texttt{gets()}.
\end{itemize}
\begin{lstlisting}[style=cStyle, caption={Check for no input}]
    int number;
    printf("Enter a number between 1 and 30: ");
    scanf("%d", &number);

    while ((number<1) || (number>30))
    {
        printf("Invalid number. Please enter a number between 1 and 30: ");
        scanf("%d", &number);
    }
\end{lstlisting}

\section{Functions}
\subsection{Protype and Definition}
\textbf{Protype :} A function prototype is a declaration of a function that tells the compiler what the function looks like. It includes the function name, return type, and parameter types. The prototype must be declared before the function is called.\\[2ex]
\textbf{Definition :} A function definition is the actual implementation of the function. It includes the function name, return type, parameter types, and the body of the function. The definition must be declared after the function is called.

\subsection{Call-by-value and Pointers}
In C is it important to distuinguish between a variable and the value stored in it. A variable has a location in memory. The value of the variable is stored in that location. For example:
\begin{lstlisting}[style=cStyle]
int i = 10;
\end{lstlisting}
tells the system to allocate a location in memory to store the value 10. The variable \texttt{i} is a pointer to that location in memory. One of the distuinguihing features of C is it we can manipulate the memory address of the variable almost as easily as we can manipulate the value stored in it.
\subsubsection*{Pointers}
\begin{itemize}
    \item if \texttt{i} is a variable, then \texttt{\&i} is a pointer to the location in memory where the value of \texttt{i} is stored.
    \item The declaration \texttt{int *p;} creates a variable \texttt{p} that can store the memory address of an integer. The \texttt{*} indicates that \texttt{p} is a pointer to an integer.
    \item If a memory address is stored in the variable \texttt{p}, then \texttt{*p} is the value stored at that address.
\end{itemize}

\section{Characters and Strings}
In C, a character is just an unsigned integer. Each character is represented by an integer between 0 and 127.
\subsection{Reading and writing characters}
\begin{minipage}{0.45\textwidth}
    \textbf{Printing characters:}

    \begin{itemize}
        \item \texttt{printf("\&c", c)}
        \item \texttt{putchar(c)}
    \end{itemize}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \textbf{Reading characters:}
    \begin{itemize}
        \item \texttt{scanf("\&c", c)}
        \item \texttt{c = getchar()}
    \end{itemize}
\end{minipage}
\pagebreak
\subsection{Strings}
C does not have a string data type. Instead it uses arrays of type char to represent strings. For example if we make a declaration:
\texttt{char greeting[20]="Hello. How are you?";}
the system stores each character as an element of the array greeting.


\subsection{String functions}
Useful functions defined in \texttt{string.h}: \\[2ex]
\textbf{srncpy()} \\
\texttt{char *strncp(char *dest, char *src, int n)} \\
Copies at most \texttt{n} characters from \texttt{src} to \texttt{dest}. The advantage of this is that we don't copy more chatavyers to \texttt{dest} than it can hold (prevents buffer overflow). \texttt{strncpy()} does not append a null character to the end of the string, so we need to do that manually. \\[2ex]
\textbf{strcat()} \\
\texttt{char *strcat(char *dest, char *src)} \\
Concatenates the string \texttt{src} to the end of the string \texttt{dest}. The destination string must be large enough to hold the concatenated result. \texttt{strcat()} appends a null character to the end of the string. \\[2ex]
\textbf{strcmp()} \\
\texttt{int strcmp(char *str1, char *str2)} \\
Compares two strings annd returns an intger:
\begin{itemize}
    \item 0 if the strings are equal
    \item A negative integer if \texttt{str1} comes first alphabetically
    \item A negative integer if \texttt{str2} comes first alphabetically
\end{itemize}
\textbf{strstr()} \\
\texttt{char *strstr(char *haystack, char *needle)} \\
Searches for the first occurrence of the string \texttt{needle} in the string \texttt{haystack}. If found, it returns a pointer to the first occurrence of \texttt{needle} in \texttt{haystack}. If not found, it returns NULL. \\[2ex]
\textbf{strlen()} \\
\texttt{int strlen(char *str)} \\
Returns the length of the string \texttt{str} (not including the null character).
\subsubsection{String Output}
We know how to use \texttt{printf()} to print strings:
\begin{itemize}
    \item \texttt{printf("\%s\%s$\backslash$n, "Good Morning ", name);}
    \item \texttt{printf("\%s\%8s$\backslash$n", "Good Morning ", name);}
\end{itemize}
The second example, the field width specifier is given. This causes the string to be padded so it takes up a total of 8 spaces. If the string is shorter than 8 characters, it is padded with spaces on the left. If the string is longer than 8 characters, it is printed as is. \\[2ex]
\textbf{String Input} \\
Input is a more complicated issue, there are three basis methods:
\begin{itemize}
    \item \texttt{scanf("\%s", name);} reads the next "word" from th input stream and stores it in the array \texttt{name}. A "word" is defined as a sequence of characters separated without a space, tab, or newline. The string is terminated with a null character.
    \item \texttt{getchar(name);} to get more control of the input in a loop
    \item \texttt{gets(string);} reads a line input and stores it all except the newline character. The string is terminated with a null character. \texttt{gets()} is not safe to use because it does not check the length of the input string. If the input string is longer than the array, it will cause a buffer overflow and overwrite other data in memory.
    \item \texttt{fgets(string, n, stdin);} reads in a line of text from the keyboard (standard input stream) and stores at most \texttt{n} characters in the array \texttt{string}. The string is terminated with a null character. If the input string is longer than \texttt{n}, it will be truncated and the rest will be discarded. \texttt{fgets()} is safer to use than \texttt{gets()} because it checks the length of the input string.
\end{itemize}

\section{Arrays}
To declare a $3 \times 4$ matrix of floats, we write \texttt{float a[3][4];}. So:
$$\begin{bmatrix}
        a[0][0] & a[0][1] & a[0][2] & a[0][3] \\
        a[1][0] & a[1][1] & a[1][2] & a[1][3] \\
        a[2][0] & a[2][1] & a[2][2] & a[2][3]
    \end{bmatrix}
$$
In general, an $n \times m$ array is declared as \texttt{float a[n][m];}. The first index is the row number and the second index is the column number. The first element of the array is \texttt{a[0][0]} and the last element is \texttt{a[n-1][m-1]}. \\[2ex]
If a has the line \texttt{int [a][4];} then the system creats three arrays, each of length four. More precisely, it:
\begin{itemize}
    \item declares 3 pointers to type \texttt{int}: \texttt{a[0]}, \texttt{a[1]}, and \texttt{a[2]}
    \item space for storing an integer is allocated to each of addresses \texttt{a[0], a[0]+1, a[0]+2, a[0]+3, a[1], a[1]+1}, $\dots$, \texttt{a[2]+3}
\end{itemize}
This mean is if \texttt{a[][]} is declared as a two-dimensional $3 \times 4$ array, then the following are equivalent:
\begin{itemize}
    \item \texttt{a[1][2]}
    \item \texttt{*(a[1]+2)}
    \item \texttt{*(*(a+1)+2)}
    \item \texttt{*(\&a[0][0]+4+2)}
\end{itemize}
\subsection{Explanation of Array Element Access in C}

\subsubsection*{\texttt{a[1][2]}}
This is the standard way to access a two-dimensional array element. It directly fetches the element in the second row (index 1) and the third column (index 2).

\subsubsection*{\texttt{*(a[1]+2)}}
\begin{itemize}
    \item \texttt{a[1]} yields the second row, which decays to a pointer to its first element (i.e., equivalent to \texttt{\&a[1][0]}).
    \item Adding \texttt{2} moves the pointer two elements forward in that row.
    \item The dereference operator \texttt{*} then accesses the element at that position, which is \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(*(a+1)+2)}}
\begin{itemize}
    \item \texttt{a+1} moves the pointer from the first row to the second row.
    \item \texttt{*(a+1)} dereferences that pointer to yield the address of the first element of the second row (again, equivalent to \texttt{a[1]}).
    \item Adding \texttt{2} moves to the third element in that row, and the outer \texttt{*} fetches its value---again, \texttt{a[1][2]}.
\end{itemize}

\subsubsection*{\texttt{*(\&a[0][0]+4+2)}}
\begin{itemize}
    \item \texttt{\&a[0][0]} gets the address of the very first element of the array.
    \item Since the array is stored in contiguous memory, pointer arithmetic treats it as a flat sequence. Adding \texttt{4+2} (i.e., 6) moves the pointer to the 7th element in that sequence.
    \item If the layout of the array is such that the element \texttt{a[1][2]} is the 7th element (this is true, for example, if the row length is at least 3), then dereferencing this pointer retrieves \texttt{a[1][2]}.
\end{itemize}

\section{Files}
Taking an input from a file is not much different than taking input from a keyboard. All we do is:
\begin{itemize}
    \item Declare an identifier of type \texttt{FILE} to hold the file pointer.
    \item Open the file (\texttt{fopen()})
    \item Read the file
    \item Close the file (\texttt{fclose()})
\end{itemize}
\subsection{Declaring a file indentifier:}
$$\texttt{FILE *datafile;}$$
The datafile is now a pointer we can associate with a file. The \texttt{FILE} type is defined in the \texttt{stdio.h} library.
\subsection{Opening a file:}
$$\texttt{fileptr = fopen(char *filename, char *mode);}$$
The \texttt{fopen()} is a function that is use for file opening. It takes two arguments: the name of a file and the mode it will operrate in. A file pointer is returned. The mode can be:
\begin{itemize}
    \item \texttt{r} : read (open an existing file for reading)
    \item \texttt{w} : write (overrwite the file or create a new one)
    \item \texttt{a} : append (add to the end of the file)
\end{itemize}
\subsection{Closing a File}
$$\texttt{fclose(fileptr);}$$
Once a file is “closed” we can no longer read from it or write to it, unless
we open it again. If we don’t do this, the file will still be closed when the
program terminates. But until then, no other program on the same node
(computer) can work with the file, and it might but be fully written to
storage
\subsection{Reading from a file}
$$\texttt{fgets(char *str, int n, FILE *fileptr);}$$
reads in a line of text from the fileptr stream and stores at most n
characters in array sting. The mew line character is stored.
If the string can’t be read, because we have reached the end of the file,
then NULL is returned.
$$\texttt{fgetc(FILE *fileptr);}$$
reads the next character in the file and stores it in the char variable c. If
the end of the file has been reached, EOF is returned.
$$\texttt{fscanf(FILE *fileptr, char *format, ...);}$$
reads formatted input from the file. The format string is similar to the
one used in \texttt{printf()}
\subsection{Navigating a file}
Each time a character is reader from the input stream, a counter associated with the stream is incremented.
$$\texttt{rewind(FILE *fileptr);}$$
sets the indicator to the start of the file
$$\texttt{ftell(FILE *fileptr);}$$
is used to check the current value of the file position indivator in the form of a long int.
$$\texttt{fseek(FILE *fileptr, long offset, int place);}$$
the value of offset is the amount the indicator will be changed by, while placce is one of:
\begin{itemize}
    \item \texttt{SEEK\_SET(0)} : the start of the file
    \item \texttt{SEEK\_CUR(1)} : the current position in the file
    \item \texttt{SEEK\_END(2)} : the end of the file
\end{itemize}
\subsection{Writing to a file}
To write to a file, we declare a file pointer:
$$\texttt{FILE *outfile;}$$
and open a new file in write mode:
$$\texttt{outfile = fopen("myList.txt", "w");}$$
to write to the file, we use one of:
\begin{itemize}
    \item \texttt{fprintf(outfile, char *format, ...);} : works like \texttt{printf()} except its first argument is a file pointer
    \item \texttt{fputs(char *str, FILE *fileptr);} : writes the string str to the file pointed to by fileptr, without its trailing '\texttt{\textbackslash 0}' character. The string is not formatted.
    \item \texttt{fputc(int c, FILE *fileptr);} : writes the character c to the file pointed to by fileptr. The character is not formatted.
\end{itemize}
\subsection{Issues concerining the use of files in C, we should be aware of:}
\begin{itemize}
    \item There are 6 modes a file can have: \texttt{r, w, a, r+, w+, a+}
    \item To open a binary file, also add a \texttt{b} to the mode. For example, \texttt{rb} opens a file for reading in binary mode.
    \item \texttt{freopen()} attaches a new file to an existing file pointer. It is used to redirect the standard input or output to a file. For example, \texttt{freopen("myList.txt", "w", stdout);} redirects the standard output to the file \texttt{myList.txt}. This means that any output that would normally go to the screen will now go to the file.
    \item \texttt{tmpfile()} open a tempory file in binary read/write and is automatically deleted when closed or when the program terminates
    \item \texttt{fflush(fileptr);} flushes the output buffer of the file pointer. This means that any data that has been buffered but not yet written to the file will be written to the file.
    \item \texttt{remove("myList.txt");} deletes the file \texttt{myList.txt} from the disk.
    \item \texttt{rename("myList.txt", "myList2.txt");} renames the file \texttt{myList.txt} to \texttt{myList2.txt}. If the new name already exists, it will be overwritten.
    \item \texttt{int feof(FILE *fileptr);} returns a non-zero value if the end of the file has been reached. It is used to check if we have reached the end of the file while reading it.
\end{itemize}

\section{The Process}
$$\textbf{"A process is a running program."}$$
The operating system gives the impression many programs are running at the same time, but in reality, only one program is running at a time. This is made possible by abstracting the the concept of a running program as a process.
\subsubsection*{Every process consists of}
\begin{itemize}
    \item The process text - the program code
    \item The program counter - the address of the next instruction to be executed
    \item The process stack - temporary data, local variables, function parameters, return addresses
    \item The data section - global variables
\end{itemize}
A process is not just a program - if two users run the same program at the same time, they create different processes. Each process has its own memory space, so they do not interfere with each other. A program is a passive entity, while a process is an active / dynamic entity.
\subsubsection*{A set of operations OS must apply to a process}
\begin{itemize}
    \item \textbf{Create} a new process (open a new program)
    \item \textbf{Terminate / Destory} a process (close a program)
    \item \textbf{Wait} or pause a process until some event occurs (e.g. waiting for user input)
    \item \textbf{Supsend and Resume} similar to wait but more explicit
    \item \textbf{Status}  report info about a process (e.g. how much memory it is using, how long it has been running, etc.)
\end{itemize}
\subsubsection*{The state of a process}
The state of a process is defined by the current activity of that process.
\begin{itemize}
    \item \textbf{New} - the process is being created
    \item \textbf{Running} - instructions being executed
    \item \textbf{Block / Waiting} - waiting for some event to occur (e.g. I/O operation)
    \item \textbf{Ready} - waiting to be assigned to a processor
    \item \textbf{Terminated} - the process has finished executing
\end{itemize}
\subsection{Process Creation}
A parent createas a child process, which create other child processes, forming a tree of processes. After a parent creates a child process it may:
\begin{itemize}
    \item Execute concurrently with the child process
    \item Wait until the child process terminates to continue
\end{itemize}
The parent may share all, some or none of the resources with the child process (resources include memory space, open files, etc.).

\subsubsection{Process Indentification Number (PID)}
All processes have a unique identifier called a PID. If we create a child process in C, using a \texttt{fork()} a new process is created:
\begin{itemize}
    \item The new process runs concurrently with the parent, unless we instruct it to \texttt{wait()}.
    \item The subproc (child) is given a copy of the parents memory space
    \item At the time of creation, the two processes are identical, except the \texttt{fork()} returns te child process' PID to the parent and 0 to the child.
\end{itemize}
In order to use this function, we must include the \texttt{unistd.h} library, which includes:
\begin{itemize}
    \item \texttt{fork()} - creates a new process
    \item \texttt{getpid()} - returns the PID of the calling process
    \item \texttt{getppid()} - returns the PID of the parent process
\end{itemize}
\begin{lstlisting}[style=cStyle, caption={Forking a process}]
    #include <unistd.h>
    #include <stdio.h>

    int main(void)
    {
        pid_t pid1, mypid;
        pid1 = fork();
        mypid = getpid();
        printf("I am %d\t", mypid);
        printf("Fork returned %d\n", pid1);
        return 0;
    }

    Output:
    I am 7791. Fork returned 0
    I am 7790. Fork returned 7791
\end{lstlisting}
\subsubsection*{\texttt{fork()}}
The proptype for \texttt{fork()} is:
$$\texttt{pid\_t fork(void);}$$
\begin{itemize}
    \item It takes no arguments
    \item It really returns an \texttt{int}
    \item It returns -1 if the fork failed
    \item Otherwise, it returns the PID of the newly created child process to the parent process
    \item It returns 0 to the child process
    \item The child process is distinct from the parent (it gets its own copy of the parent's memory space)
    \item Both parent and child process run concurrently
    \item Starting from the \texttt{fork()} call, the parent and child process execute the same instruction set.
\end{itemize}
$$\texttt{pid\_t getpid(void);}$$
Returns the value of the processes own PID
$$\texttt{pid\_t getppid(void);}$$
Returns the value of the parent process' PID
Since the parent and subproc (child) have copies of the same memory space and instruction set, \texttt{getpid()}  and \texttt{getppid()} are useful for working out which is which.
\subsubsection{Process Programing}
Often we don't want the parent to continue running while the child is running, the results may be non-deterministic. For example:
\begin{lstlisting}[style=cStyle, caption={Unpredictable a process}]
    int main(void)
    {
        int i;
        fork();
        srand(getpid()); // different seed for each process
        printf("Watch me (%d) count to 10: ", getpid());
        for (i=1; i<=10; i++)
        {
            sleep(rand()%2); // sleep for 0 or 1 seconds
            printf("%3d...", i);
            fflush(stdout);
        }
        printf("\n");
        return 0;
    }

    Output:
    Watch me (11695) count to 10: 1... 2... 3...Watch me (11696) count
    to 10: 1... 4... 2... 5... 6... 3... 7... 4... 8... 5...
    9... 6... 10... 7... 8... 9... 10...
\end{lstlisting}
$$\texttt{pid\_t wait(int *wstatus);}$$
It returns the PID of the child process the parent was waiting for and its status. Acall to the wait() function suspends the execution of the parent
process until such time as the child process completes (or, at least,
signals to the parent – more about that later)
\begin{lstlisting}[style=cStyle, caption={Wait for a process}]
    #include <sys/wait.h>
    int main(void)
    {
        pid_t pid1 = fork();
        srand(getpid()); // different seed for each process
        if (pid1 != 0) // Parent follows this path
            wait(NULL);
        printf("Watch me (%d) count to 10: ", getpid());
        for (int i = 1; i <= 10; i++) {
            sleep(rand() % 2); // sleep for 0 or 1 seconds
            printf("%3d...", i);
            fflush(stdout);
        }
        printf("\n");
        return 0;
    }
\end{lstlisting}
Recall, a sub-proc will share the parents memory only in a sense that it recieves a copy. The  child process can mimic the parents execution as in the examples above or its memory space may be overlaid with a new program/set of instructions. \\
Often when a cild process is created it is overlaid with another program. In C, this can be done with the {exelclp()} function. In the following example, the sub-procs memory space is overlaid the program text of the ls command.  Again we will use the \texttt{wait()} function.

\begin{lstlisting}[style=cStyle, caption={Overlaying a process using execlp}]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void)
{
    pid_t pid1 = fork();
    if (pid1 == 0) {
        // child
        printf("This is process %d\t", getpid());
        printf("Here is a directory listing:\n");
        execlp("ls", "ls", NULL);
    } else {
        // parent
        int p = wait(NULL);
        printf("This is process %d\t", getpid());
        printf("Wait returned %d, so subproc %d is done.\n", p, pid1);
    }
    return 0;
}
\end{lstlisting}
The OS is responsible for de-allocating the resources of a process that has finished. It may also be responsible for terminating a process that is not responding. Process termination occurs when:
\begin{itemize}
    \item The proc executes its last instruction and asks the operating system to delete it (\texttt{exit()}). At that time it will usualy:
          \begin{itemize}
              \item Output data from subproc to parent (via \texttt{wait()})
              \item Have its resources de-allocated by the OS
          \end{itemize}
    \item Parent terminates a child process because:
          \begin{itemize}
              \item Sub-proc has exceeded allocated resources
              \item The task assigned to the sub-proc is no longer needed
          \end{itemize}
    \item The parent is existing and the Os does not allow subproc to continue if the parent is terminated
\end{itemize}
On unix system, when a process terminates, its subprocs are reparented (adopted) by the init process. The mechanism for this is through "signals" and the \texttt{kill()} function. The \texttt{kill()} function is used to send a signal to a process.

\subsection{Signals}
The \texttt{kill()} system call is an example of a signal - a form of communication from one process to another. These provide a facility for asynchronus event handling. Note - when the subproc sends the kill() signal to the parent, the subproc also terminates. \\
The \texttt{kill()} function can send other signals, but most (such as SIGABRT, SIGILL, SIGQUIT, SIGTERM) are just variants of SIGKILL. However there are signals that preform other taks:
\begin{itemize}
    \item \textbf{SIGSTOP} - stops a process
    \item \textbf{SIGCONT} - continues a stopped process
    \item \textbf{SIGUSR1} - user defined signal 1
    \item \textbf{SIGUSR2} - user defined signal 2
\end{itemize}
$$\texttt{int kill(pid\_t pid, int sig);}$$
The \texttt{kill()} function takes two arguments: the PID of the process to send the signal to and the signal to send. The function returns 0 on success and -1 on failure. The \texttt{kill()} function can be used to send any signal to any process, including itself. \\
With the \texttt{signal()} function, we can send a signal that tells the process to preform a specific asction, when it recieves a \texttt{SIGUSR1} or \texttt{SIGUSR2} signal.
\begin{lstlisting}[style=cStyle, caption={Signal handling}]
    void signal_handler1(int sig);

    int main(void)
    {
        pid_t subproc_pid = fork(); // New process will send signal to parent
        
        if (subproc_pid != 0) {
            // parent
            signal(SIGUSR1, signal_handler1); // What to do if I get signaled
            sleep(100); // Wait potentially a long time
            printf("%d got woken \n", getpid());
            kill(subproc_pid, SIGKILL); // tell watcher to terminate.
        } else {
            // child
            printf("I am the sub-proc (%d)\n", getpid());
            printf("Should %d signal parent (%d)? ('y'/'n')\n",
                   getpid(), getppid());
            if (getchar() == 'y') {
                printf("Sending siguser 1 to parent\n");
                kill(getppid(), SIGUSR1);
            }
        }
        return 0;
    }

    void signal_handler1(int sig) {
        printf("Proc %d called signal_handler1() with signal %d\n",
               getpid(), sig);
    }
\end{lstlisting}
What the process does after it has finished calling the signal hander function depends on the situation. In the example above, it stopped sleeping. However if it had been making a blocking call, such as taking input from the keyboard, or reading from a pipe, it returns to doing that.

\subsubsection{IPC - Inter Process Communication}
Two processes that are executing on the same computer may be either:
\begin{itemize}
    \item Independent - cannot affect or be affected by each other
    \item Co-operating - Can be affected by the execution of eachother
\end{itemize}
We allow processes communication so we can faciliate:
\begin{itemize}
    \item \textbf{Information sharing} - two procs might require acess to the same file
    \item \textbf{Modularity} - Different procs might be dedicated to different system functions
    \item \textbf{Convenience} - a user might be running an editor, spell checker and printer all for the same file
    \item \textbf{Computational Speed} - on a multiprocessing system tasks are sub-divided and executred conrurrently on different processors.
\end{itemize}
\begin{definitionbox}Producer-Consumer Model
    One process (editor) has information it wants to produce for consumption by another process (printer-driver). This may be done using a \textbf{mutual buffer}. The producer write to the buffer and consumer reads for it.
\end{definitionbox}

\end{document}